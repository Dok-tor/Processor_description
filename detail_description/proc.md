# Здесь будет по порядку идти описание каждого файла процессора RISK-V, его назначение, устройство и способы использования


Файл `ALU.v` представляет собой описание модуля Arithmetic Logic Unit (ALU) на языке Verilog. ALU является важным компонентом процессора, выполняющим арифметические и логические операции над входными данными.

### Зачем нужен ALU

ALU (Arithmetic Logic Unit) необходим для выполнения основных вычислительных операций в процессоре. Эти операции включают в себя сложение, вычитание, логические операции (AND, OR, XOR), сдвиги и сравнения. ALU играет ключевую роль в выполнении команд, обеспечивая обработку данных, которые затем используются другими частями процессора.

### Как устроен ALU

ALU в данном модуле имеет следующие основные компоненты:

1. **Параметры и входы/выходы:**
   - `DATA_WIDTH`: Параметр, задающий ширину данных (по умолчанию 32 бита).
   - `ALU_operation`: 6-битный вход, определяющий операцию, которую нужно выполнить.
   - `operand_A` и `operand_B`: Операнды, над которыми выполняются операции.
   - `ALU_result`: Выход, содержащий результат операции.

2. **Внутренние сигналы:**
   - `signed_operand_A` и `signed_operand_B`: Операнды, интерпретируемые как знаковые числа.
   - `shamt`: Сигнал сдвига, используемый для операций сдвига.
   - Различные промежуточные сигналы для знаковых операций, таких как арифметический сдвиг вправо, сравнения.

3. **Логика операций:**
   - В зависимости от значения `ALU_operation`, выбирается одна из множества операций:
     - Сложение (`ADD`)
     - Передача операнда (`JAL`, `JALR`)
     - Сравнение на равенство (`BEQ`)
     - Логические операции (AND, OR, XOR)
     - Сдвиги (логический и арифметический)
     - Вычитание (`SUB`)
     - И другие операции сравнения (меньше, больше или равно, знаковые и беззнаковые сравнения)

### Как используется ALU

ALU используется в процессоре для выполнения вычислений, необходимых при выполнении команд. Управляющий блок процессора передает операнды и код операции в ALU. В зависимости от кода операции, ALU выполняет соответствующую вычислительную операцию и возвращает результат.

Пример использования:
- В команде сложения (например, `ADD`), ALU принимает два операнда и возвращает их сумму.
- В команде сравнения (например, `BEQ`), ALU проверяет, равны ли два операнда, и возвращает логическое значение (истина или ложь).

ALU является центральным элементом, обеспечивающим выполнение большинства операций в процессоре, и его правильное функционирование критически важно для работы всей системы.


# ------------------------------------------------------------------------------

Файл `arbiter.v` описывает модуль арбитра на языке Verilog. Арбитр используется для управления доступом к общим ресурсам в многозадачных системах или системах с несколькими мастерами.

### Зачем нужен арбитр

Арбитр необходим для разрешения конфликтов доступа к общим ресурсам, таким как шина данных или память. Когда несколько устройств или процессоров пытаются получить доступ к одному и тому же ресурсу одновременно, арбитр определяет, кому из них предоставить доступ. Это предотвращает коллизии и обеспечивает упорядоченный доступ к ресурсу.

### Как устроен арбитр

Арбитр в данном модуле имеет следующие основные компоненты:

1. **Параметры и входы/выходы:**
   - `WIDTH`: Параметр, задающий количество возможных запросов (по умолчанию 4).
   - `clock`, `reset`: Входы для синхронизации и сброса.
   - `requests`: Входной сигнал, представляющий запросы от различных устройств.
   - `grant`: Выходной сигнал, представляющий индекс устройства, которому предоставлен доступ к ресурсу.

2. **Функция log2:**
   - Вспомогательная функция для вычисления логарифма по основанию 2 от заданного значения, используется для определения ширины выходного сигнала `grant`.

3. **Регистры и провода:**
   - `mask`: Регистр, используемый для маскирования запросов.
   - `masked_requests`, `masked_valid`, `unmasked_valid`, `masked_encoded`, `unmasked_encoded`: Внутренние сигналы для работы с запросами и приоритетными кодировщиками.

4. **Приоритетные кодировщики:**
   - `priority_encoder`: Инстанции приоритетных кодировщиков, используемые для кодирования запросов с маскированием и без маскирования.

5. **Основная логика арбитра:**
   - В блоке always на положительном фронте сигнала `clock` происходит обновление маски. Если активен сигнал `reset`, маска устанавливается в 1 для всех битов. В противном случае, маска обновляется в зависимости от значения сигнала `grant`.
   - `masked_requests` формируется путем применения маски к запросам.
   - `grant` устанавливается в значение, соответствующее закодированному запросу с учетом маски или без неё, в зависимости от наличия активных маскированных запросов.

### Как используется арбитр

Арбитр используется в системах с общими ресурсами, где несколько устройств могут одновременно посылать запросы на доступ. Входной сигнал `requests` представляет собой набор битов, где каждый бит соответствует запросу от одного из устройств. На выходе арбитр формирует сигнал `grant`, указывающий индекс устройства, которому предоставлен доступ.

Пример использования:
- В системе с несколькими процессорами, каждый процессор может послать запрос на доступ к памяти через шину данных. Арбитр принимает эти запросы и определяет, какому процессору предоставить доступ в текущий момент времени.

Арбитр обеспечивает справедливое и упорядоченное распределение ресурсов, что важно для стабильной работы системы.


# ------------------------------------------------------------------------------

Файл `BRAM.v` описывает модуль блока RAM (BRAM - Block RAM) на языке Verilog. Этот модуль представляет собой блочную память с произвольным доступом, используемую в системах на кристалле (SoC) и FPGA для хранения данных и инструкций.

### Зачем нужен BRAM

BRAM используется для организации внутренней памяти в цифровых системах. Он обеспечивает быструю и эффективную память с произвольным доступом, которая может использоваться для хранения данных, программ, кэш-памяти и других временных данных, необходимых для выполнения вычислений и управления потоками данных внутри процессора или другого цифрового устройства.

### Как устроен BRAM

BRAM в данном модуле имеет следующие основные компоненты:

1. **Параметры и входы/выходы:**
   - `CORE`: Параметр, задающий идентификатор ядра (по умолчанию 0).
   - `DATA_WIDTH`: Параметр, задающий ширину данных (по умолчанию 32 бита).
   - `ADDR_WIDTH`: Параметр, задающий ширину адреса (по умолчанию 8 бит).
   - `SCAN_CYCLES_MIN` и `SCAN_CYCLES_MAX`: Параметры, задающие диапазон циклов для сканирования.
   - `clock`, `reset`: Входы для синхронизации и сброса.
   - `readEnable`, `readAddress`: Входы для управления чтением из памяти.
   - `readData`: Выход, содержащий данные, считанные из памяти.
   - `writeEnable`, `writeAddress`, `writeData`: Входы для управления записью в память.
   - `scan`: Вход для управления режимом сканирования.

2. **Локальные параметры:**
   - `MEM_DEPTH`: Глубина памяти, определяемая как `2^ADDR_WIDTH`.

3. **Регистры и массивы:**
   - `ram`: Массив для хранения данных памяти.
   - `readData`: Регистр для хранения данных, считанных из памяти.
   - `cycles`: Регистр для подсчета циклов, используемый в режиме сканирования.

4. **Основная логика работы:**
   - **RAM_READ**: Блок always, который выполняет чтение из памяти на каждом положительном фронте сигнала `clock`. Если одновременно активны сигналы `readEnable` и `writeEnable`, и адреса чтения и записи совпадают, то `readData` принимает значение `writeData`. В противном случае, если активен только сигнал `readEnable`, `readData` принимает значение из памяти по адресу `readAddress`.
   - **RAM_WRITE**: Блок always, который выполняет запись в память на каждом положительном фронте сигнала `clock`, если активен сигнал `writeEnable`. Запись происходит по адресу `writeAddress`, данные берутся из `writeData`.
   - **Сканирование**: Блок always, который увеличивает счетчик `cycles` на каждом положительном фронте сигнала `clock`, если не активен сигнал `reset`. В режиме сканирования (`scan` активен и текущий цикл попадает в диапазон от `SCAN_CYCLES_MIN` до `SCAN_CYCLES_MAX`), выводится информация о текущем состоянии операций чтения и записи.

### Как используется BRAM

BRAM используется как внутренняя память в различных цифровых системах. Он может применяться для хранения инструкций и данных, необходимых для выполнения программ, а также для временного хранения промежуточных данных.

Пример использования:
- В процессоре BRAM может использоваться как оперативная память для хранения текущих данных программы и промежуточных результатов вычислений.
- В FPGA BRAM может использоваться для хранения конфигурационных данных или в качестве буферной памяти для обработки потоков данных.

BRAM обеспечивает высокую скорость доступа и гибкость в управлении памятью, что делает его важным компонентом в цифровых системах.


# ------------------------------------------------------------------------------

Файл `cache_controller.v` описывает модуль контроллера кэша на языке Verilog. Контроллер кэша управляет доступом к кэш-памяти, координирует операции чтения и записи, обеспечивает когерентность данных и взаимодействует с основной памятью.

### Зачем нужен контроллер кэша

Контроллер кэша необходим для управления кэш-памятью процессора. Он обеспечивает:
- Быстрое получение данных из кэша.
- Управление кэш-попаданиями (hits) и кэш-промахами (misses).
- Когерентность данных в многопроцессорных системах.
- Координацию операций чтения и записи между кэшем и основной памятью.

### Как устроен контроллер кэша

Контроллер кэша имеет следующие основные компоненты:

1. **Параметры и входы/выходы:**
   - **Параметры:** Определяют различные размеры и характеристики кэша (например, ширина данных, количество путей, количество бит адреса и т.д.).
   - **Входы:** Сигналы для управления кэш-памятью (чтение, запись, адрес, данные и т.д.).
   - **Выходы:** Сигналы статуса и данные, возвращаемые из кэша или основной памяти.

2. **Локальные параметры:**
   - Определяют глубину кэша, количество слов в строке, количество бит для метки и т.д.

3. **Состояния автомата:**
   - Определяют различные состояния контроллера кэша, такие как RESET, IDLE, CACHE_ACCESS, READ_STATE, WRITE_BACK и другие.

4. **Внутренние регистры и провода:**
   - Хранят текущие данные и метаданные кэша, включая адреса запросов, данные, теги, когорентные и статусные биты.

5. **Логика управления состояниями:**
   - Внутренний автомат управления (FSM) определяет переходы между различными состояниями в зависимости от входных сигналов и текущего состояния кэша.

6. **Интерфейсы с кэш-памятью и основной памятью:**
   - Управляют взаимодействием между контроллером кэша и кэш-памятью (data_in0, tag_in0, coh_bits0 и т.д.).
   - Обеспечивают взаимодействие с основной памятью для обработки кэш-промахов и записи обратно (write-back).

### Как используется контроллер кэша

Контроллер кэша используется для управления доступом к кэш-памяти в процессорах и других цифровых системах. Он координирует операции чтения и записи, обеспечивает когерентность данных и взаимодействует с основной памятью для обработки кэш-промахов.

Пример использования:
- Когда процессор хочет прочитать данные по определенному адресу, контроллер кэша проверяет, находятся ли данные в кэше (кэш-попадание). Если данные есть в кэше, они немедленно возвращаются процессору. Если данных в кэше нет (кэш-промах), контроллер кэша инициирует чтение данных из основной памяти.
- При записи данных контроллер кэша обновляет данные в кэше и, если необходимо, обеспечивает запись данных в основную память для сохранения когерентности данных.

Контроллер кэша является критически важным компонентом для повышения производительности системы за счет уменьшения времени доступа к памяти и обеспечения когерентности данных в многопроцессорных средах.

# ------------------------------------------------------------------------------


Файл `cache_hierarchy.v` описывает иерархию кэша, включающую в себя кэши первого уровня (L1) и кэш второго уровня (L2). Он также управляет взаимодействием между кэшами и основной памятью. 

### Зачем нужна иерархия кэша

Иерархия кэша необходима для повышения производительности процессора путем уменьшения времени доступа к данным. Кэш первого уровня (L1) обеспечивает очень быструю память, расположенную ближе всего к ядрам процессора. Кэш второго уровня (L2) служит промежуточным хранилищем, уменьшая количество обращений к основной памяти. Такая структура позволяет эффективнее использовать данные, сокращая задержки и увеличивая пропускную способность системы.

### Как устроена иерархия кэша

Иерархия кэша включает несколько основных компонентов:

1. **Параметры и входы/выходы:**
   - **Параметры:** Определяют характеристики кэш-памяти, такие как количество битов состояния, битов когерентности, количество путей ассоциативности и т.д.
   - **Входы:** Сигналы для управления операциями чтения, записи, инвалидации, сброса, адреса, данных и т.д.
   - **Выходы:** Сигналы данных, статуса и адреса, возвращаемые из кэша или основной памяти.

2. **Локальные параметры:**
   - Определяют количество слов на шине, ширину шины, количество портов на шине, параметры L2 кэша и т.д.

3. **Внутренние сигналы:**
   - Сигналы для передачи данных и адресов между различными уровнями кэша и шиной данных.

4. **Инстанцирование кэшей первого уровня (L1):**
   - Кэш первого уровня обрабатывает запросы от процессоров и взаимодействует с шиной данных и контроллером когерентности.

5. **Инстанцирование кэша второго уровня (L2):**
   - Кэш второго уровня обрабатывает запросы от кэшей первого уровня и взаимодействует с основной памятью.

6. **Инстанцирование контроллеров шины и когерентности:**
   - Контроллеры шины и когерентности управляют доступом к шине и обеспечивают когерентность данных между различными уровнями кэша и основной памятью.

### Как используется иерархия кэша

Иерархия кэша используется для управления доступом к памяти и оптимизации производительности системы. 

Пример использования:
- Когда процессор запрашивает данные, запрос сначала поступает в кэш L1. Если данные находятся в кэше L1 (кэш-попадание), они немедленно возвращаются процессору. Если данных нет в кэше L1 (кэш-промах), запрос передается в кэш L2.
- Если данные находятся в кэше L2, они передаются обратно в кэш L1, а затем в процессор. Если данных нет и в кэше L2, запрос передается в основную память.
- Контроллер когерентности обеспечивает согласованность данных, предотвращая ситуации, когда одно и то же данные могут быть обновлены в разных кэшах одновременно.

Контроллер шины координирует передачу данных между различными компонентами системы, обеспечивая эффективное использование шины данных и предотвращая конфликты доступа.

Таким образом, иерархия кэша значительно уменьшает задержки доступа к данным, улучшает производительность и обеспечивает когерентность данных в многопроцессорных системах.


# ------------------------------------------------------------------------------

Файл `cache_memory.v` описывает модуль кэш-памяти на языке Verilog. Этот модуль управляет кэш-памятью, обеспечивая доступ к данным, когерентность данных и замену данных в кэше.

### Зачем нужна кэш-память

Кэш-память необходима для хранения часто используемых данных и инструкций, чтобы уменьшить задержки при доступе к памяти и повысить производительность процессора. Она позволяет быстро получать доступ к часто используемым данным, избегая долгих циклов обращения к основной памяти.

### Как устроена кэш-память

Кэш-память в данном модуле имеет следующие основные компоненты:

1. **Параметры и входы/выходы:**
   - **Параметры:** Определяют характеристики кэша, такие как количество битов состояния, битов когерентности, количество путей ассоциативности, ширину данных, количество битов адреса и индекса и т.д.
   - **Входы:** Сигналы для управления операциями чтения, записи, инвалидации, сброса, адреса, данных и т.д.
   - **Выходы:** Сигналы данных, статуса, тегов, битов когерентности и битов состояния, возвращаемые из кэша.

2. **Локальные параметры:**
   - Определяют количество слов на строку, ширину блока данных, количество битов метки и другие параметры.

3. **Регистры и провода:**
   - Хранят текущие данные и метаданные кэша, включая адреса запросов, данные, теги, когерентные и статусные биты.

4. **Модули двойного портового RAM:**
   - Модули двойного портового RAM используются для хранения данных и метаданных (теги и статусные биты) кэша. Каждый путь кэша имеет свой модуль RAM.

5. **Контроллер замены:**
   - Контроллер замены управляет процессом выбора пути для замены в случае кэш-промаха, обеспечивая использование различных стратегий замены.

6. **Декодеры "one-hot":**
   - Декодеры используются для преобразования меток в формат "one-hot", чтобы определить, какой путь соответствует запрашиваемому тегу.

### Как используется кэш-память

Кэш-память используется для ускорения доступа к данным и инструкциям, которые часто используются процессором. 

Пример использования:
- Когда процессор хочет прочитать данные по определенному адресу, запрос поступает в кэш. Если данные находятся в кэше (кэш-попадание), они немедленно возвращаются процессору. Если данных нет в кэше (кэш-промах), запрос передается в контроллер замены, который определяет, какой путь заменить, и данные загружаются из основной памяти.
- При записи данных контроллер кэша обновляет данные в соответствующем пути кэша и, если необходимо, обеспечивает когерентность данных между различными уровнями кэша и основной памятью.

### Основные элементы модуля:

1. **Функция log2:**
   - Вспомогательная функция для вычисления логарифма по основанию 2 от заданного значения.

2. **Локальные параметры:**
   - Определяют глубину кэша, количество слов на строку, количество битов для метки и т.д.

3. **Регистры и провода:**
   - Хранят текущие данные и метаданные кэша, включая адреса запросов, данные, теги, когерентные и статусные биты.

4. **Модули двойного портового RAM:**
   - Модули двойного портового RAM используются для хранения данных и метаданных кэша.

5. **Контроллер замены:**
   - Управляет процессом выбора пути для замены в случае кэш-промаха.

6. **Декодеры "one-hot":**
   - Преобразуют метки в формат "one-hot", чтобы определить, какой путь соответствует запрашиваемому тегу.

### Логика работы:

- **Чтение и запись данных:**
  - Запросы на чтение и запись обрабатываются контроллером кэша, который определяет, находятся ли данные в кэше и какой путь использовать для доступа к данным.
  
- **Сравнение тегов:**
  - Сравнение тегов используется для определения, находится ли запрашиваемый адрес в кэше (кэш-попадание) или нет (кэш-промах).

- **Управление замещением:**
  - Контроллер замены определяет, какой путь заменить в случае кэш-промаха, основываясь на стратегии замены (например, LRU - Least Recently Used).

Таким образом, модуль кэш-памяти обеспечивает эффективное управление кэшем, что позволяет значительно уменьшить задержки доступа к данным и повысить производительность системы.


# ------------------------------------------------------------------------------

Файл `coherence_controller.v` описывает модуль контроллера когерентности на языке Verilog. Этот модуль управляет когерентностью кэш-памяти в многопроцессорных системах, обеспечивая согласованность данных между различными кэшами и основной памятью.

### Зачем нужен контроллер когерентности

Контроллер когерентности необходим для управления согласованностью данных в системах с несколькими уровнями кэшей и многопроцессорных системах. Он обеспечивает правильное обновление и распространение данных между кэшами различных процессоров, предотвращая несогласованность данных, которая может привести к ошибкам в вычислениях.

### Как устроен контроллер когерентности

Контроллер когерентности имеет следующие основные компоненты:

1. **Параметры и входы/выходы:**
   - **Параметры:** Определяют характеристики контроллера, такие как количество битов сообщений и количество кэшей.
   - **Входы:** Сигналы для управления когерентностью, включая сообщения от кэшей, сообщения от памяти и текущее состояние шины.
   - **Выходы:** Сигналы управления шиной и состояние текущего мастера шины.

2. **Локальные параметры:**
   - Определяют количество портов на шине, ширину сигналов шины и состояния автомата.

3. **Внутренние регистры и провода:**
   - Хранят текущие данные и метаданные, включая сообщения от кэшей, состояние текущего мастера шины и владельца транзакции.

4. **Арбитр и декодеры:**
   - Арбитр управляет распределением доступа к шине между различными кэшами.
   - Декодеры преобразуют сигналы из одного формата в другой, обеспечивая правильное управление состояниями и сигналами.

5. **Логика управления состояниями:**
   - Внутренний автомат управления (FSM) определяет переходы между различными состояниями в зависимости от входных сигналов и текущего состояния шины и кэшей.

### Как используется контроллер когерентности

Контроллер когерентности используется для управления доступом к шине данных и обеспечения согласованности данных в многопроцессорных системах. Он координирует операции чтения и записи между кэшами и основной памятью, обеспечивая когерентность данных.

Пример использования:
- Когда процессор хочет записать данные в память, контроллер когерентности обеспечивает обновление соответствующих данных в кэшах других процессоров, предотвращая несогласованность данных.
- При чтении данных контроллер когерентности обеспечивает получение актуальных данных из соответствующего кэша или основной памяти.

### Основные элементы модуля:

1. **Функция log2:**
   - Вспомогательная функция для вычисления логарифма по основанию 2 от заданного значения.

2. **Локальные параметры:**
   - Определяют количество портов на шине, ширину сигналов шины и состояния автомата.

3. **Регистры и провода:**
   - Хранят текущие данные и метаданные, включая сообщения от кэшей, состояние текущего мастера шины и владельца транзакции.

4. **Арбитр и декодеры:**
   - Арбитр управляет распределением доступа к шине между различными кэшами.
   - Декодеры преобразуют сигналы из одного формата в другой.

5. **Контрольные сигналы:**
   - `requests`: Определяет запросы от кэшей на выполнение операций.
   - `tr_coherence_op`: Отслеживает когерентные сообщения от кэшей.
   - `tr_en_access`: Отслеживает доступные операции от кэшей.

### Логика работы:

- **Состояния автомата:**
  - `IDLE`: Начальное состояние, в котором контроллер ожидает запросы.
  - `WAIT_EN`: Ожидание разрешения на выполнение операции.
  - `COHERENCE_OP`: Выполнение когерентной операции.
  - `WAIT_FOR_MEM`: Ожидание ответа от памяти.
  - `HOLD`: Удержание шины для текущего мастера.
  - `END_TRANSACTION`: Завершение текущей транзакции.
  - `MEM_HOLD`: Удержание шины для операции памяти.

- **Управление шиной:**
  - Контроллер управляет доступом к шине данных, назначая текущего мастера и разрешая выполнение операций.
  - При получении запроса от кэша контроллер назначает соответствующего мастера и инициирует операцию на шине.

Таким образом, контроллер когерентности обеспечивает согласованность данных в многопроцессорных системах, управляет доступом к шине данных и координирует операции между различными кэшами и основной памятью.


# ------------------------------------------------------------------------------

Файл `control_unit.v` описывает модуль управляющего устройства (Control Unit) на языке Verilog. Управляющее устройство является важной частью процессора, так как оно отвечает за декодирование инструкций и генерацию управляющих сигналов для выполнения этих инструкций.

### Зачем нужно управляющее устройство

Управляющее устройство необходимо для декодирования инструкций, поступающих из памяти, и генерации соответствующих управляющих сигналов, которые управляют различными частями процессора (например, ALU, регистровым файлом, памятью и т.д.). Оно обеспечивает правильное выполнение инструкций и координацию работы процессора.

### Как устроено управляющее устройство

Управляющее устройство в данном модуле имеет следующие основные компоненты:

1. **Параметры и входы/выходы:**
   - **Параметры:** Определяют характеристики управляющего устройства, такие как количество битов адреса, количество байтов и логарифм от количества байтов.
   - **Входы:** Сигналы для декодирования инструкции и состояния процессора, включая opcode, funct3, funct7, адреса целевых инструкций и различные опасности (hazards).
   - **Выходы:** Сигналы управления для различных частей процессора, включая сигналы выбора операндов, управления ALU, чтения/записи памяти и регистров, а также выбор следующего адреса программы (PC).

2. **Функция log2:**
   - Вспомогательная функция для вычисления логарифма по основанию 2 от заданного значения.

3. **Локальные параметры:**
   - Определяют различные типы инструкций, такие как R-type, I-type, LOAD, STORE, BRANCH и т.д.

4. **Логика декодирования инструкций:**
   - Декодирует opcode и генерирует соответствующие управляющие сигналы для выполнения инструкции.

### Как используется управляющее устройство

Управляющее устройство используется для декодирования инструкций и генерации управляющих сигналов, необходимых для выполнения этих инструкций процессором. 

Пример использования:
- Когда процессор получает инструкцию из памяти, управляющее устройство декодирует opcode и другие поля инструкции (funct3, funct7) и генерирует соответствующие сигналы для управления ALU, регистровым файлом, памятью и другими частями процессора.
- Например, для инструкции LOAD управляющее устройство генерирует сигналы для чтения из памяти, выбора регистра назначения и установления правильного размера данных.

### Основные элементы модуля:

1. **Логика декодирования инструкций:**
   - `regWrite`: Определяет, следует ли записывать результат операции в регистровый файл.
   - `memWrite`: Определяет, следует ли записывать данные в память.
   - `branch_op`: Определяет, является ли инструкция ветвлением.
   - `memRead`: Определяет, следует ли читать данные из памяти.

2. **Логика выбора размера данных:**
   - `log2_bytes`: Определяет количество байтов, используемых в операции LOAD или STORE, в зависимости от funct3.

3. **Логика выбора операции ALU:**
   - `ALU_operation`: Определяет операцию, которую должен выполнить ALU, на основе opcode, funct3 и funct7.

4. **Логика выбора операндов:**
   - `operand_A_sel` и `operand_B_sel`: Определяют, какие операнды должны быть использованы ALU.
   - `extend_sel`: Определяет тип расширения для непосредственных значений (sign-extend или zero-extend).

5. **Логика управления следующим адресом программы (PC):**
   - `next_PC_sel`: Определяет, какой адрес должен быть использован для следующего значения PC (например, в случае ветвления или перехода).
   - `target_PC`: Определяет целевой адрес для инструкций JAL, JALR и ветвлений.

6. **Регистры и вывод информации:**
   - Счетчик циклов `cycles` используется для мониторинга текущего состояния управления и вывода информации при включенном сканировании.

### Логика работы:

- **Декодирование инструкций:**
  - Управляющее устройство декодирует текущую инструкцию, определяя ее тип (R-type, I-type, LOAD, STORE, BRANCH и т.д.) и генерирует соответствующие управляющие сигналы для выполнения этой инструкции.

- **Выбор операций ALU:**
  - В зависимости от типа инструкции и значений funct3 и funct7, управляющее устройство генерирует сигнал `ALU_operation`, который определяет операцию, которую должен выполнить ALU (например, сложение, вычитание, логические операции и т.д.).

- **Управление памятью и регистрами:**
  - Сигналы `memRead`, `memWrite` и `regWrite` определяют, следует ли читать или записывать данные в память или регистровый файл.

- **Управление ветвлениями и переходами:**
  - Сигналы `next_PC_sel` и `target_PC` управляют выбором следующего значения PC в случае выполнения инструкций ветвления или перехода (например, JAL, JALR).

Таким образом, управляющее устройство является центральным компонентом процессора, обеспечивающим правильное выполнение инструкций и координацию работы всех частей процессора.


# ------------------------------------------------------------------------------

Файл `decode_unit.v` описывает модуль декодирования инструкций на языке Verilog. Этот модуль является важной частью процессора, так как он отвечает за декодирование инструкций, извлечение операндов и формирование управляющих сигналов для других модулей процессора.

### Зачем нужен модуль декодирования инструкций

Модуль декодирования инструкций необходим для преобразования закодированных инструкций, поступающих из памяти, в управляющие сигналы и операнды, которые могут быть использованы другими модулями процессора для выполнения операций. Он извлекает из инструкции различные поля, такие как коды операций (opcode), регистры, константы и адреса, и передает их на выполнение.

### Как устроен модуль декодирования инструкций

Модуль декодирования инструкций имеет следующие основные компоненты:

1. **Параметры и входы/выходы:**
   - **Параметры:** Определяют характеристики модуля, такие как количество битов адреса, минимальное и максимальное количество циклов сканирования.
   - **Входы:** Сигналы для декодирования инструкции, включая текущий адрес инструкции (PC), саму инструкцию, выбор расширения (extend_sel), сигналы записи в регистры и данные для записи.
   - **Выходы:** Сигналы данных, извлеченных из регистров (rs1_data, rs2_data), регистры назначения (rd), коды операций и функции (opcode, funct3, funct7), расширенные немедленные значения (extend_imm), и адреса целевых инструкций (branch_target, JAL_target).

2. **Регистровый файл:**
   - Внутренний регистровый файл (regFile) для хранения и извлечения значений регистров.

3. **Логика декодирования инструкций:**
   - Извлечение различных полей из инструкции, таких как регистры, немедленные значения и коды операций.

4. **Логика расширения немедленных значений:**
   - Расширение различных типов немедленных значений (I-тип, S-тип, U-тип, SB-тип, UJ-тип) до 32 бит.

### Как используется модуль декодирования инструкций

Модуль декодирования инструкций используется для преобразования инструкции, поступающей из памяти, в управляющие сигналы и операнды для других модулей процессора. 

Пример использования:
- Когда процессор получает инструкцию из памяти, модуль декодирования извлекает из инструкции необходимые поля (opcode, rs1, rs2, rd, immediate) и передает их на выполнение.
- Для инструкций ветвления модуль декодирования вычисляет целевые адреса ветвления и перехода.
- Модуль декодирования также управляет чтением и записью в регистровый файл.

### Основные элементы модуля:

1. **Извлечение полей из инструкции:**
   - `rs1` и `rs2`: Номера регистров-источников.
   - `rd`: Номер регистра назначения.
   - `opcode`, `funct3`, `funct7`: Коды операций и функции.
   - Немедленные значения различных типов (I-тип, S-тип, U-тип, SB-тип, UJ-тип).

2. **Расширение немедленных значений:**
   - `i_imm_32`: Расширение немедленного значения I-типа до 32 бит.
   - `s_imm_32`: Расширение немедленного значения S-типа до 32 бит.
   - `u_imm_32`: Расширение немедленного значения U-типа до 32 бит.
   - `sb_imm_32`: Расширение немедленного значения SB-типа до 32 бит.
   - `uj_imm_32`: Расширение немедленного значения UJ-типа до 32 бит.

3. **Выбор расширенного немедленного значения:**
   - `extend_imm`: Выбор правильного расширенного немедленного значения на основе `extend_sel`.

4. **Вычисление целевых адресов ветвления и перехода:**
   - `branch_target`: Целевой адрес для инструкций ветвления.
   - `JAL_target`: Целевой адрес для инструкции JAL.

5. **Регистровый файл:**
   - Хранение и извлечение значений регистров.

6. **Мониторинг и отображение информации:**
   - Счетчик циклов `cycles` используется для мониторинга текущего состояния декодирования и вывода информации при включенном сканировании.

### Логика работы:

- **Извлечение полей из инструкции:**
  - Модуль декодирования извлекает различные поля из инструкции, такие как регистры-источники (rs1, rs2), регистр назначения (rd), коды операций (opcode) и функции (funct3, funct7).

- **Расширение немедленных значений:**
  - В зависимости от типа инструкции модуль декодирования расширяет немедленные значения до 32 бит.

- **Вычисление целевых адресов:**
  - Для инструкций ветвления и перехода модуль декодирования вычисляет целевые адреса (branch_target, JAL_target).

- **Чтение и запись в регистровый файл:**
  - Модуль декодирования управляет чтением значений регистров (rs1_data, rs2_data) и записью результатов выполнения инструкций в регистры (write_data, write_reg).

Таким образом, модуль декодирования инструкций является важным компонентом процессора, обеспечивающим правильное декодирование инструкций и подготовку операндов для выполнения.


# ------------------------------------------------------------------------------

Файл `dual_port_ram.v` описывает модуль двухпортовой оперативной памяти (RAM) на языке Verilog. Этот модуль позволяет двум независимым портам одновременно читать и записывать данные в память.

### Зачем нужна двухпортовая оперативная память

Двухпортовая оперативная память необходима для повышения производительности и эффективности систем, которым требуется одновременный доступ к памяти с двух различных портов. Она используется в различных приложениях, таких как кэш-память процессоров, буферы и другие системы, где требуется параллельный доступ к данным.

### Как устроена двухпортовая оперативная память

Модуль двухпортовой оперативной памяти имеет следующие основные компоненты:

1. **Параметры и входы/выходы:**
   - **Параметры:** Определяют характеристики памяти, такие как ширина данных (DATA_WIDTH), ширина адреса (ADDRESS_WIDTH) и количество бит индекса (INDEX_BITS).
   - **Входы:** Сигналы для управления записью и чтением данных, включая сигналы записи (we0, we1), входные данные (data_in0, data_in1), адреса (address0, address1) и тактовый сигнал (clock).
   - **Выходы:** Сигналы выходных данных (data_out0, data_out1).

2. **Локальные параметры:**
   - Определяют глубину памяти (RAM_DEPTH), которая вычисляется как 2 в степени количества бит индекса (INDEX_BITS).

3. **Регистры памяти:**
   - Внутренний массив регистров (`mem`), который хранит данные.

4. **Логика управления доступом к памяти:**
   - Управляет одновременным доступом к памяти с двух портов, предотвращая конфликты записи.

### Как используется двухпортовая оперативная память

Двухпортовая оперативная память используется для обеспечения параллельного доступа к памяти в системах, требующих высокую производительность и эффективное управление данными.

Пример использования:
- В кэш-памяти процессора, где один порт может использоваться для загрузки данных из основной памяти, а другой — для записи данных обратно в основную память.
- В буферах данных, где требуется одновременная запись и чтение данных с разных адресов.

### Основные элементы модуля:

1. **Регистры памяти:**
   - Внутренний массив регистров `mem` используется для хранения данных. Глубина памяти определяется параметром `RAM_DEPTH`.

2. **Логика записи и чтения данных:**
   - Порт A:
     - Если сигнал записи (`we0`) активен, данные записываются в память по адресу `address0`, и эти данные также передаются на выход `data_out0`.
     - Если сигнал записи неактивен, данные читаются из памяти по адресу `address0` и передаются на выход `data_out0`.
   - Порт B:
     - Если сигнал записи (`we1`) активен, данные записываются в память по адресу `address1`, и эти данные также передаются на выход `data_out1`.
     - Если сигнал записи неактивен, данные читаются из памяти по адресу `address1` и передаются на выход `data_out1`.

3. **Управление конфликтами записи:**
   - Если оба порта пытаются записывать данные в одно и то же время по одному и тому же адресу, приоритет отдается порту A (`port0_we`), чтобы предотвратить конфликт.

### Логика работы:

- **Запись данных:**
  - Когда сигнал записи (`we0` или `we1`) активен, данные записываются в память по указанному адресу. Записанные данные также немедленно передаются на соответствующий выход (`data_out0` или `data_out1`).

- **Чтение данных:**
  - Когда сигнал записи неактивен, данные читаются из памяти по указанному адресу и передаются на соответствующий выход.

- **Управление конфликтами записи:**
  - Если оба порта пытаются записывать данные по одному и тому же адресу, активируется сигнал `port0_we`, который дает приоритет порту A и предотвращает конфликт.

Таким образом, модуль двухпортовой оперативной памяти обеспечивает параллельный доступ к данным, что повышает производительность и эффективность систем, требующих одновременный доступ к памяти с двух различных портов.


# ------------------------------------------------------------------------------

Файл `dual_port_ram_with_pass_through.v` описывает модуль двухпортовой оперативной памяти с функцией "pass through" на языке Verilog. Этот модуль расширяет возможности базовой двухпортовой RAM, добавляя возможность обработки конфликтов при одновременной записи и чтении данных.

### Зачем нужна двухпортовая оперативная память с функцией "pass through"

Двухпортовая оперативная память с функцией "pass through" необходима для улучшения производительности и устранения конфликтов при одновременной записи и чтении данных из одного и того же адреса. Эта функция позволяет читать новые данные, записанные в память на том же такте, вместо старых данных, что важно для поддержания целостности данных и повышения производительности.

### Как устроена двухпортовая оперативная память с функцией "pass through"

Модуль двухпортовой оперативной памяти с функцией "pass through" имеет следующие основные компоненты:

1. **Параметры и входы/выходы:**
   - **Параметры:** Определяют характеристики памяти, такие как ширина данных (DATA_WIDTH), ширина адреса (ADDRESS_WIDTH), количество бит индекса (INDEX_BITS) и режим чтения/записи (RW).
   - **Входы:** Сигналы для управления записью и чтением данных, включая сигналы записи (we0, we1), входные данные (data_in0, data_in1), адреса (address0, address1) и тактовый сигнал (clock).
   - **Выходы:** Сигналы выходных данных (data_out0, data_out1).

2. **Регистры для хранения входных сигналов:**
   - Регистры для хранения адресов и сигналов записи, чтобы использовать их в логике "pass through".

3. **Инстанцирование базовой двухпортовой RAM:**
   - Базовый модуль двухпортовой RAM для хранения и управления доступом к данным.

4. **Логика "pass through":**
   - Обрабатывает конфликты записи и чтения, обеспечивая корректные выходные данные в случае одновременного доступа к одному и тому же адресу.

### Как используется двухпортовая оперативная память с функцией "pass through"

Двухпортовая оперативная память с функцией "pass through" используется в системах, где требуется одновременная запись и чтение данных, чтобы избежать конфликта данных и обеспечить целостность данных.

Пример использования:
- В процессорах и контроллерах памяти, где требуется одновременное чтение и запись данных с минимальной задержкой.
- В кэш-памяти, где может происходить одновременное чтение и запись данных на одном и том же адресе.

### Основные элементы модуля:

1. **Регистры для хранения входных сигналов:**
   - `r_address0`, `r_address1`: Хранят текущие адреса доступа для портов A и B.
   - `r_we0`, `r_we1`: Хранят текущие сигналы записи для портов A и B.

2. **Инстанцирование базовой двухпортовой RAM:**
   - Модуль `dual_port_ram` используется для базового хранения данных и обеспечения доступа к ним.

3. **Логика "pass through":**
   - `data_out0`: Если происходит запись на порт B и адреса портов совпадают, то на выход порта A передаются данные, записанные через порт B, иначе передаются данные, считанные с адреса порта A.
   - `data_out1`: Если происходит запись на порт A и адреса портов совпадают, то на выход порта B передаются данные, записанные через порт A, иначе передаются данные, считанные с адреса порта B.

### Логика работы:

- **Запись данных:**
  - Когда сигнал записи (`we0` или `we1`) активен, данные записываются в память по указанному адресу. Записанные данные также немедленно передаются на соответствующий выход через логику "pass through".

- **Чтение данных:**
  - Когда сигнал записи неактивен, данные читаются из памяти по указанному адресу и передаются на соответствующий выход.

- **Логика "pass through":**
  - Если одновременно происходит запись и чтение по одному и тому же адресу, данные на выходе передаются в зависимости от режима (RW) и приоритета порта. В режиме "NEW_DATA" (`RW == "NEW_DATA"`), выходной сигнал получает данные, только что записанные в память, вместо старых данных.

Таким образом, модуль двухпортовой оперативной памяти с функцией "pass through" обеспечивает параллельный доступ к данным, избегая конфликтов записи и чтения, что повышает производительность и целостность данных в системах с высокой интенсивностью операций ввода-вывода.


# ------------------------------------------------------------------------------

Файл `empty_way_select.v` описывает модуль выбора пустого пути (way) в кэш-памяти на языке Verilog. Этот модуль используется в кэш-памяти для определения, какой путь свободен для записи новых данных.

### Зачем нужен модуль выбора пустого пути

Модуль выбора пустого пути необходим для управления многопутевой кэш-памятью, где каждый путь представляет собой отдельный блок памяти. При добавлении новых данных в кэш нужно определить, какой из путей свободен, чтобы записать туда новые данные. Это помогает оптимизировать использование памяти и улучшить производительность кэш-памяти.

### Как устроен модуль выбора пустого пути

Модуль выбора пустого пути имеет следующие основные компоненты:

1. **Параметры и входы/выходы:**
   - **Параметры:** Определяют количество путей в кэш-памяти (NUMBER_OF_WAYS).
   - **Входы:** Сигнал, указывающий на занятость путей (ways_in_use).
   - **Выходы:** Сигналы, указывающие на следующий пустой путь (next_empty_way) и его валидность (valid).

2. **Функция log2:**
   - Вспомогательная функция для вычисления логарифма по основанию 2 от заданного значения.

3. **Логика выбора пустого пути:**
   - Определяет, какой путь в кэш-памяти свободен, используя инвертирование и добавление единицы к сигналу занятости путей.

### Как используется модуль выбора пустого пути

Модуль выбора пустого пути используется в контроллерах кэш-памяти для определения следующего свободного пути при записи новых данных в кэш.

Пример использования:
- Когда нужно записать новые данные в кэш-память, модуль выбора пустого пути определяет, какой из путей (ways) свободен, и указывает его для записи новых данных.

### Основные элементы модуля:

1. **Инвертирование сигнала занятости путей:**
   - `invert`: Инвертирует сигнал занятости путей, чтобы получить сигнал, указывающий на свободные пути.

2. **Добавление единицы к сигналу занятости путей:**
   - `plusone`: Добавляет единицу к сигналу занятости путей, чтобы определить следующий путь для проверки.

3. **Логика выбора пустого пути:**
   - `next_empty_way`: Определяет следующий пустой путь, используя результат инвертирования и добавления единицы.
   - `valid`: Указывает, есть ли свободные пути.

### Логика работы:

- **Инвертирование сигнала занятости путей:**
  - Сигнал `ways_in_use` инвертируется, чтобы получить сигнал `invert`, указывающий на свободные пути (где `1` означает свободный путь, а `0` - занятый).

- **Добавление единицы к сигналу занятости путей:**
  - К сигналу `ways_in_use` добавляется единица, чтобы получить сигнал `plusone`.

- **Определение следующего пустого пути:**
  - Сигнал `next_empty_way` формируется путем логического И между `invert` и `plusone`. Это позволяет выбрать следующий свободный путь для записи данных.
  - Сигнал `valid` указывает, есть ли хотя бы один свободный путь (если хотя бы один бит в `invert` равен `1`).

Таким образом, модуль выбора пустого пути помогает эффективно управлять многопутевой кэш-памятью, определяя, куда записывать новые данные, и улучшая использование доступной памяти.


# ------------------------------------------------------------------------------

### Модуль execution_unit

#### Назначение
Модуль `execution_unit` (исполнительный блок) отвечает за выполнение арифметико-логических операций и управление ветвлениями в процессоре. Это ключевой компонент процессора, который обрабатывает команды и выполняет операции, указанные в инструкциях.

#### Устройство

Модуль параметризован, что позволяет настроить его под разные архитектуры процессоров. Параметры включают:
- `CORE`: идентификатор ядра.
- `DATA_WIDTH`: ширина данных (по умолчанию 32 бита).
- `ADDRESS_BITS`: количество бит в адресах (по умолчанию 20).
- `SCAN_CYCLES_MIN` и `SCAN_CYCLES_MAX`: диапазон циклов для сканирования и отладки.

#### Интерфейсы (входы и выходы)
- **Входы:**
  - `clock`: тактовый сигнал.
  - `reset`: сигнал сброса.
  - `ALU_operation`: код операции для АЛУ.
  - `PC`: счетчик команд.
  - `operand_A_sel`: выбор источника для операнда A.
  - `operand_B_sel`: выбор источника для операнда B.
  - `branch_op`: сигнал операции ветвления.
  - `rs1_data`, `rs2_data`: данные из регистровых файлов.
  - `extend`: расширенные данные для операндов.
  - `scan`: сигнал сканирования для отладки.

- **Выходы:**
  - `branch`: сигнал ветвления.
  - `ALU_result`: результат выполнения операции АЛУ.
  - `JALR_target`: целевой адрес для JALR (Jump And Link Register).

#### Логика работы

1. **Определение операндов:**
   - `operand_A` выбирается на основе значения `operand_A_sel` и может быть равен `PC`, `PC+4`, нулю или `rs1_data`.
   - `operand_B` выбирается между `extend` и `rs2_data` на основе значения `operand_B_sel`.

2. **Выполнение ветвления:**
   - `branch` устанавливается в 1, если результат АЛУ равен 1 и операция является ветвлением (`branch_op`).

3. **Определение целевого адреса для JALR:**
   - `JALR_target` определяется как сумма `rs1_data` и `extend`, где младший бит всегда обнуляется.

4. **Выполнение операций АЛУ:**
   - Операция определяется по коду `ALU_operation`, а результат записывается в `ALU_result`.

5. **Отладка и сканирование:**
   - В блоке всегда отслеживается количество тактовых циклов. При включенном сигнале `scan` и в заданном диапазоне циклов (`SCAN_CYCLES_MIN`, `SCAN_CYCLES_MAX`), текущие значения операндов, результата АЛУ и других сигналов выводятся для отладки.

#### Использование

Этот модуль используется в процессорных ядрах для выполнения вычислительных операций и операций ветвления. Он берет команды, определяет операнды, выполняет указанные операции и возвращает результаты, а также обрабатывает переходы в программах.

### Пример использования
Процессор, содержащий данный модуль, может выполнять различные арифметические и логические операции, управлять переходами и изменениями адресов на основе результатов вычислений, что делает его важной частью архитектуры процессора.


# ------------------------------------------------------------------------------

### Модуль fetch_issue

#### Назначение
Модуль `fetch_issue` отвечает за получение и выдачу адресов команд в процессоре. Этот модуль управляет программным счетчиком (PC), определяя следующий адрес команды для выборки из памяти. Его задача состоит в инкрементировании, удержании или изменении адреса команд в зависимости от условий, таких как переходы и ветвления.

#### Устройство

Модуль параметризован для гибкой настройки под разные архитектуры:
- `CORE`: идентификатор ядра.
- `RESET_PC`: начальное значение программного счетчика (по умолчанию 0).
- `ADDRESS_BITS`: количество бит в адресах (по умолчанию 20).
- `SCAN_CYCLES_MIN` и `SCAN_CYCLES_MAX`: диапазон циклов для сканирования и отладки.

#### Интерфейсы (входы и выходы)
- **Входы:**
  - `clock`: тактовый сигнал.
  - `reset`: сигнал сброса.
  - `next_PC_select`: выбор следующего значения для PC.
  - `target_PC`: целевой адрес для переходов.
  - `scan`: сигнал сканирования для отладки.

- **Выходы:**
  - `issue_PC`: текущий адрес PC.
  - `i_mem_read_address`: адрес для чтения команды из памяти.

#### Логика работы

1. **Определение следующего адреса PC:**
   - При сбросе (`reset`) программный счетчик устанавливается в значение `RESET_PC`.
   - В обычном режиме работы значение `PC_reg` обновляется в зависимости от значения `next_PC_select`:
     - `2'b00`: Инкрементирование PC (`PC = PC + 4`).
     - `2'b01`: Удержание текущего значения PC (`PC = PC`).
     - `2'b10`: Переход/ветвление на целевой адрес (`PC = target_PC`).
     - По умолчанию: Установка PC в нулевое значение.

2. **Выходные сигналы:**
   - `issue_PC` и `i_mem_read_address` всегда равны текущему значению `PC_reg`.

#### Использование

Этот модуль используется в процессоре для управления выборкой команд. Он обновляет программный счетчик в зависимости от условий, таких как переходы или ветвления, и передает текущий адрес для чтения команды из памяти.

### Пример использования
Модуль `fetch_issue` является важной частью процессорного конвейера, отвечая за правильное и последовательное получение команд. Он позволяет организовать выполнение программ путем управления программным счетчиком, что обеспечивает корректное выполнение команд в заданном порядке или по определенным условиям переходов.

#### Схема переходов next_PC_select
- `2'b00`: Инкрементирование PC (переход к следующей команде).
- `2'b01`: Удержание текущего значения PC (задержка, например, при ожидании готовности данных).
- `2'b10`: Переход на целевой адрес (ветвление или прыжок).


# ------------------------------------------------------------------------------

### Модуль five_stage_bypass_unit

#### Назначение
Модуль `five_stage_bypass_unit` отвечает за управление обходом данных в процессоре с пятиступенчатым конвейером. Этот модуль решает проблемы передачи данных между стадиями конвейера, обеспечивая своевременную передачу нужных данных без необходимости ожидания завершения всей команды. Это позволяет избежать задержек из-за зависимостей данных.

#### Устройство

Модуль параметризован для настройки под разные процессорные ядра и возможности отладки:
- `CORE`: идентификатор ядра.
- `SCAN_CYCLES_MIN` и `SCAN_CYCLES_MAX`: диапазон циклов для сканирования и отладки.

#### Интерфейсы (входы и выходы)
- **Входы:**
  - `clock`: тактовый сигнал.
  - `reset`: сигнал сброса.
  - `true_data_hazard`: сигнал, указывающий на истинную зависимость данных.
  - `rs1_hazard_execute`, `rs1_hazard_memory`, `rs1_hazard_writeback`: сигналы опасности для первого источника данных (rs1) на стадиях исполнения, памяти и записи соответственно.
  - `rs2_hazard_execute`, `rs2_hazard_memory`, `rs2_hazard_writeback`: сигналы опасности для второго источника данных (rs2) на стадиях исполнения, памяти и записи соответственно.
  - `scan`: сигнал сканирования для отладки.

- **Выходы:**
  - `rs1_data_bypass`: сигнал управления мультиплексором для обхода данных rs1.
  - `rs2_data_bypass`: сигнал управления мультиплексором для обхода данных rs2.

#### Логика работы

1. **Генерация сигналов обхода данных:**
   - Для первого источника данных (`rs1_data_bypass`):
     - Если есть опасность на стадии исполнения (`rs1_hazard_execute`) и нет истинной зависимости данных (`~true_data_hazard`), то `rs1_data_bypass` устанавливается в `2'b01`.
     - Если есть опасность на стадии памяти (`rs1_hazard_memory`) и нет истинной зависимости данных, то `rs1_data_bypass` устанавливается в `2'b10`.
     - Если есть опасность на стадии записи (`rs1_hazard_writeback`) и нет истинной зависимости данных, то `rs1_data_bypass` устанавливается в `2'b11`.
     - В остальных случаях `rs1_data_bypass` устанавливается в `2'b00`.

   - Аналогичная логика применяется для второго источника данных (`rs2_data_bypass`).

2. **Отладка и сканирование:**
   - Количество тактовых циклов отслеживается и при включенном сигнале `scan` и в заданном диапазоне циклов (`SCAN_CYCLES_MIN`, `SCAN_CYCLES_MAX`), текущие значения сигналов обхода выводятся для отладки.

#### Использование

Этот модуль используется в процессорах с пятиступенчатым конвейером для предотвращения задержек, вызванных зависимостями данных. Он определяет, какие данные необходимо обходить из более поздних стадий конвейера к более ранним, что позволяет избежать простоев и повышает производительность процессора.

### Пример использования

Модуль `five_stage_bypass_unit` обеспечивает своевременную передачу данных в процессорах, содержащих несколько стадий конвейера, таких как стадии исполнения, памяти и записи. Это важно для обеспечения высокой производительности и эффективности процессора, позволяя выполнять команды без ненужных задержек, вызванных зависимостями данных.


# ------------------------------------------------------------------------------

### Модуль five_stage_control_unit

#### Назначение
Модуль `five_stage_control_unit` представляет собой блок управления процессором с пятиступенчатым конвейером. Он отвечает за генерацию управляющих сигналов для различных стадий конвейера, обработку опасностей данных и управление обходами данных. Модуль интегрирует в себя несколько подмодулей, таких как блоки управления опасностями, блоки управления остановками и блоки обхода.

#### Устройство

Модуль параметризован для настройки под различные архитектуры:
- `CORE`: идентификатор ядра.
- `ADDRESS_BITS`: количество бит в адресах (по умолчанию 20).
- `NUM_BYTES`: количество байт (по умолчанию 4).
- `LOG2_NUM_BYTES`: логарифм по основанию 2 от `NUM_BYTES`.
- `SCAN_CYCLES_MIN` и `SCAN_CYCLES_MAX`: диапазон циклов для сканирования и отладки.

#### Интерфейсы (входы и выходы)

- **Входы:**
  - `clock`: тактовый сигнал.
  - `reset`: сигнал сброса.
  - `opcode_decode`, `opcode_execute`, `opcode_memory`: коды операций для соответствующих стадий конвейера.
  - `funct3`, `funct7`: поля `funct3` и `funct7` из декодируемой команды.
  - `JALR_target_execute`, `branch_target_execute`, `JAL_target_decode`: целевые адреса для ветвлений и переходов.
  - `branch_execute`: сигнал выполнения ветвления.
  - `fetch_valid`, `fetch_ready`: сигналы валидности и готовности выборки.
  - `issue_PC`, `fetch_address_in`: адреса для выдачи и выборки.
  - `memory_valid`, `memory_ready`: сигналы валидности и готовности памяти.
  - `load_memory`, `store_memory`: сигналы загрузки и записи памяти.
  - `load_address`, `memory_address_in`: адреса загрузки и памяти.
  - `rs1`, `rs2`, `rd_execute`, `rd_memory`, `rd_writeback`: регистры исходных и целевых данных.
  - `regWrite_execute`, `regWrite_memory`, `regWrite_writeback`: сигналы записи в регистры на различных стадиях конвейера.
  - `scan`: сигнал сканирования для отладки.

- **Выходы:**
  - `branch_op`, `memRead`, `memWrite`, `unsigned_load`, `regWrite`: управляющие сигналы для различных операций.
  - `ALU_operation`: операция АЛУ.
  - `log2_bytes`: количество байт в логарифме по основанию 2.
  - `next_PC_sel`, `operand_A_sel`, `operand_B_sel`, `extend_sel`: сигналы выбора для различных мультиплексоров.
  - `target_PC`: целевой адрес для перехода.
  - `i_mem_read`: сигнал чтения инструкции из памяти.
  - `stall_decode`, `stall_execute`, `stall_memory`: сигналы остановки на различных стадиях конвейера.
  - `flush_decode`, `flush_execute`, `flush_writeback`: сигналы сброса на различных стадиях конвейера.
  - `rs1_data_bypass`, `rs2_data_bypass`: сигналы управления обходом данных.

#### Логика работы

1. **Определение опасностей и обходов данных:**
   - Логика определения чтения регистров `rs1_read` и `rs2_read` основывается на кодах операций.
   - Опасности данных (`rs1_hazard_*` и `rs2_hazard_*`) определяются на различных стадиях конвейера, а также учитываются истинные опасности загрузки (`rs1_true_hazard` и `rs2_true_hazard`).

2. **Модули обработки опасностей, остановок и обходов:**
   - Модуль `hazard_detection_unit` определяет различные типы опасностей, такие как опасности данных и памяти, и генерирует соответствующие сигналы.
   - Модуль `five_stage_stall_unit` управляет остановками и сбросами на различных стадиях конвейера, основываясь на сигналах опасностей.
   - Модуль `five_stage_bypass_unit` определяет сигналы управления обходами данных для предотвращения задержек из-за зависимостей данных.

3. **Основной блок управления:**
   - Модуль `control_unit` генерирует управляющие сигналы для различных операций на основе входных сигналов и состояния конвейера.

#### Использование

Этот модуль используется для управления процессором с пятиступенчатым конвейером, обеспечивая корректную обработку команд, управление переходами, обход данных и обработку различных опасностей, связанных с зависимостями данных и доступом к памяти.

### Пример использования

Модуль `five_stage_control_unit` является центральным компонентом управления процессором, отвечая за синхронизацию и координацию всех стадий конвейера. Он позволяет эффективно управлять выполнением команд, обрабатывая опасности данных и обеспечивая обходы, что важно для высокой производительности и надежности процессора.


# ------------------------------------------------------------------------------

### Модуль five_stage_core

#### Назначение
Модуль `five_stage_core` представляет собой ядро процессора с пятиступенчатым конвейером. Он объединяет все основные компоненты процессора, такие как блоки выборки, декодирования, исполнения, памяти и записи, и координирует их работу для выполнения команд.

#### Устройство

Модуль параметризован для гибкой настройки:
- `CORE`: идентификатор ядра.
- `RESET_PC`: начальное значение программного счетчика (по умолчанию 0).
- `DATA_WIDTH`: ширина данных (по умолчанию 32 бита).
- `ADDRESS_BITS`: количество бит в адресах (по умолчанию 32).
- `NUM_BYTES`: количество байт (по умолчанию 4).
- `SCAN_CYCLES_MIN` и `SCAN_CYCLES_MAX`: диапазон циклов для сканирования и отладки.

#### Интерфейсы (входы и выходы)
- **Входы:**
  - `clock`: тактовый сигнал.
  - `reset`: сигнал сброса.
  - `start`: сигнал начала выполнения.
  - `program_address`: начальный адрес программы.
  - `fetch_valid`, `fetch_ready`: сигналы валидности и готовности выборки.
  - `fetch_data_in`: данные выборки.
  - `fetch_address_in`: адрес выборки.
  - `memory_valid`, `memory_ready`: сигналы валидности и готовности памяти.
  - `memory_data_in`: данные памяти.
  - `memory_address_in`: адрес памяти.
  - `scan`: сигнал сканирования для отладки.

- **Выходы:**
  - `fetch_read`: сигнал чтения выборки.
  - `fetch_address_out`: адрес выборки.
  - `memory_read`, `memory_write`: сигналы чтения и записи памяти.
  - `memory_byte_en`: байтовые сигналы памяти.
  - `memory_address_out`: адрес памяти.
  - `memory_data_out`: данные памяти.

#### Логика работы

Модуль состоит из нескольких стадий конвейера, каждая из которых реализована с помощью соответствующих подмодулей:

1. **Fetch Stage (Стадия выборки):**
   - Модуль `fetch_issue` отвечает за выборку команды из памяти.
   - Команда и адрес выборки передаются в конвейерную регистр для дальнейшей обработки.

2. **Decode Stage (Стадия декодирования):**
   - Модуль `five_stage_decode_unit` декодирует команды, извлекает операнды и генерирует управляющие сигналы.
   - Обеспечивает обход данных для минимизации задержек.

3. **Execute Stage (Стадия исполнения):**
   - Модуль `execution_unit` выполняет арифметико-логические операции и ветвления.
   - Результаты операций передаются в следующую стадию через конвейерные регистры.

4. **Memory Stage (Стадия работы с памятью):**
   - Модуль `memory_issue` управляет чтением и записью данных в память.
   - Модуль `memory_receive` получает данные из памяти и передает их в стадию записи.

5. **Writeback Stage (Стадия записи):**
   - Модуль `writeback_unit` записывает результаты выполнения команд обратно в регистры.

#### Пример использования

Модуль `five_stage_core` используется в составе процессора для выполнения команд в пять стадий, что позволяет достигнуть высокой производительности за счет параллельного выполнения команд. Этот модуль обеспечивает эффективную обработку команд, управление переходами и ветвлениями, а также работу с памятью, что делает его важным компонентом в современных процессорных архитектурах.

#### Компоненты

- **Параметры и функции:**
  - Параметры задают размеры данных и адресов, а также идентификатор ядра и диапазоны для отладки.
  - Функция `log2` используется для вычисления логарифма по основанию 2.

- **Внутренние сигналы и провода:**
  - Внутренние сигналы и провода используются для передачи данных и управляющих сигналов между стадиями конвейера.

- **Конвейерные регистры:**
  - Регистры используются для передачи данных и управляющих сигналов между стадиями конвейера.

### Заключение

Модуль `five_stage_core` является центральным компонентом процессора с пятиступенчатым конвейером, обеспечивая синхронизацию и координацию всех стадий конвейера для эффективного выполнения команд.


# ------------------------------------------------------------------------------

### Модуль five_stage_decode_unit

#### Назначение
Модуль `five_stage_decode_unit` отвечает за декодирование инструкций, определение операндов и формирование управляющих сигналов для следующих стадий конвейера в процессоре. Этот модуль также обрабатывает обход данных для минимизации задержек из-за зависимостей данных.

#### Устройство

Модуль параметризован для гибкой настройки:
- `CORE`: идентификатор ядра.
- `DATA_WIDTH`: ширина данных (по умолчанию 32 бита).
- `ADDRESS_BITS`: количество бит в адресах (по умолчанию 20).
- `SCAN_CYCLES_MIN` и `SCAN_CYCLES_MAX`: диапазон циклов для сканирования и отладки.

#### Интерфейсы (входы и выходы)

- **Входы:**
  - `clock`: тактовый сигнал.
  - `reset`: сигнал сброса.
  - `PC`: текущий программный счетчик.
  - `instruction`: декодируемая инструкция.
  - `extend_sel`: выбор расширения для немедленных значений.
  - `write`: сигнал записи.
  - `write_reg`: регистр назначения для записи.
  - `write_data`: данные для записи в регистр.
  - `rs1_data_bypass`, `rs2_data_bypass`: сигналы управления обходом данных.
  - `ALU_result_execute`, `ALU_result_memory`, `ALU_result_writeback`: результаты АЛУ из разных стадий конвейера.
  - `scan`: сигнал сканирования для отладки.

- **Выходы:**
  - `rs1_data`: данные из первого исходного регистра.
  - `rs2_data`: данные из второго исходного регистра.
  - `rd`: регистр назначения.
  - `opcode`: код операции.
  - `funct7`: поле `funct7` инструкции.
  - `funct3`: поле `funct3` инструкции.
  - `extend_imm`: расширенное немедленное значение.
  - `branch_target`: целевой адрес ветвления.
  - `JAL_target`: целевой адрес для JAL (Jump And Link).

#### Логика работы

1. **Обход данных:**
   - Модуль реализует логику обхода данных, чтобы минимизировать задержки из-за зависимостей данных.
   - Данные для регистров `rs1` и `rs2` выбираются из различных источников в зависимости от сигналов `rs1_data_bypass` и `rs2_data_bypass`:
     - `2'b00`: данные из регистра `rs1_data_decode` или `rs2_data_decode`.
     - `2'b01`: результат АЛУ из стадии исполнения (`ALU_result_execute`).
     - `2'b10`: результат АЛУ из стадии памяти (`ALU_result_memory`).
     - `2'b11`: результат АЛУ из стадии записи (`ALU_result_writeback`).

2. **Декодирование инструкции:**
   - Модуль использует подмодуль `decode_unit` для декодирования инструкции.
   - Подмодуль `decode_unit` определяет значения различных полей инструкции, таких как `opcode`, `funct3`, `funct7`, а также извлекает операнды и вычисляет немедленные значения.

#### Использование

Этот модуль используется в составе процессора для декодирования инструкций, извлечения операндов и формирования управляющих сигналов. Он также обрабатывает обход данных, чтобы минимизировать задержки и обеспечить эффективное выполнение команд.

### Пример использования

Модуль `five_stage_decode_unit` является ключевым компонентом в конвейере процессора, обеспечивая декодирование инструкций и обработку данных. Он взаимодействует с другими модулями, такими как `execution_unit`, `memory_unit` и `writeback_unit`, для обеспечения корректного и эффективного выполнения команд.

### Компоненты

- **Параметры:**
  - Параметры задают ширину данных и адресов, а также идентификатор ядра и диапазоны для отладки.

- **Входные и выходные сигналы:**
  - Входные сигналы включают в себя тактовый сигнал, сигнал сброса, текущий программный счетчик, декодируемую инструкцию и сигналы управления обходом данных.
  - Выходные сигналы включают данные из регистров, регистр назначения, код операции, поля `funct3` и `funct7`, расширенные немедленные значения и целевые адреса для ветвлений и переходов.

- **Подмодуль decode_unit:**
  - Подмодуль `decode_unit` отвечает за непосредственное декодирование инструкции и формирование соответствующих сигналов.

### Заключение

Модуль `five_stage_decode_unit` является важным компонентом в процессоре с пятиступенчатым конвейером, обеспечивая декодирование инструкций, извлечение операндов и обработку данных для эффективного выполнения команд.


# ------------------------------------------------------------------------------

### Модуль five_stage_stall_unit

#### Назначение
Модуль `five_stage_stall_unit` отвечает за управление остановками и сбросами в конвейере процессора с пятью стадиями. Основная цель этого модуля — предотвращение и обработка различных опасностей, которые могут возникнуть в процессе выполнения инструкций, таких как истинные зависимости данных, опасности памяти и ветвлений.

#### Устройство

Модуль параметризован для гибкой настройки:
- `CORE`: идентификатор ядра.
- `SCAN_CYCLES_MIN` и `SCAN_CYCLES_MAX`: диапазон циклов для сканирования и отладки.

#### Интерфейсы (входы и выходы)

- **Входы:**
  - `clock`: тактовый сигнал.
  - `reset`: сигнал сброса.
  - `true_data_hazard`: сигнал истинной зависимости данных.
  - `d_mem_hazard`: сигнал опасности данных памяти.
  - `i_mem_hazard`: сигнал опасности инструкционной памяти.
  - `JALR_branch_hazard`: сигнал опасности ветвления JALR.
  - `JAL_hazard`: сигнал опасности JAL.
  - `scan`: сигнал сканирования для отладки.

- **Выходы:**
  - `stall_decode`: сигнал остановки стадии декодирования.
  - `stall_execute`: сигнал остановки стадии исполнения.
  - `stall_memory`: сигнал остановки стадии памяти.
  - `flush_decode`: сигнал сброса стадии декодирования.
  - `flush_execute`: сигнал сброса стадии исполнения.
  - `flush_writeback`: сигнал сброса стадии записи.

#### Логика работы

1. **Приоритеты остановок и сбросов:**
   - Опасности с более высоким приоритетом имеют преимущество над опасностями с более низким приоритетом.
   - Приоритеты для стадии декодирования (Decode):
     1. Опасности данных памяти (`d_mem_hazard`) — остановка.
     2. Опасности ветвления JALR (`JALR_branch_hazard`) — сброс.
     3. Истинные зависимости данных (`true_data_hazard`) — остановка.
     4. Опасности JAL (`JAL_hazard`) — сброс.
     5. Опасности инструкционной памяти (`i_mem_hazard`) — сброс.
   - Приоритеты для стадии исполнения (Execute):
     1. Опасности данных памяти (`d_mem_hazard`) — остановка.
     2. Истинные зависимости данных (`true_data_hazard`) — сброс.
     3. Опасности ветвления JALR (`JALR_branch_hazard`) — сброс.

2. **Определение сигналов остановки и сброса:**
   - Сигнал остановки для стадии декодирования (`stall_decode`) активируется при наличии опасностей данных памяти или истинных зависимостей данных (если нет опасности ветвления JALR).
   - Сигнал остановки для стадии исполнения (`stall_execute`) активируется при наличии опасностей данных памяти.
   - Сигнал остановки для стадии памяти (`stall_memory`) активируется при наличии опасностей данных памяти.
   - Сигнал сброса для стадии декодирования (`flush_decode`) активируется при наличии опасностей ветвления JALR (если нет опасности данных памяти) или опасностей JAL/инструкционной памяти (если нет истинных зависимостей данных и опасностей данных памяти).
   - Сигнал сброса для стадии исполнения (`flush_execute`) активируется при наличии истинных зависимостей данных или опасностей ветвления JALR (если нет опасностей данных памяти).
   - Сигнал сброса для стадии записи (`flush_writeback`) активируется при наличии опасностей данных памяти.

3. **Отладка и сканирование:**
   - Количество тактовых циклов отслеживается, и при включенном сигнале `scan` и в заданном диапазоне циклов (`SCAN_CYCLES_MIN`, `SCAN_CYCLES_MAX`), текущие значения сигналов остановки и сброса выводятся для отладки.

#### Использование

Этот модуль используется для управления остановками и сбросами в конвейере процессора, что необходимо для правильного выполнения инструкций при наличии различных опасностей. Он предотвращает выполнение инструкций, которые могут привести к некорректной работе процессора, и обеспечивает корректное управление конвейером.

### Пример использования

Модуль `five_stage_stall_unit` является ключевым компонентом в процессоре с пятиступенчатым конвейером, обеспечивая правильное управление остановками и сбросами при наличии опасностей. Он помогает предотвращать ошибки и обеспечивает эффективное выполнение команд, минимизируя задержки и сохраняя целостность выполнения программы.


# ------------------------------------------------------------------------------

### Описание модуля `hazard_detection_unit`

#### Назначение
Модуль `hazard_detection_unit` предназначен для обнаружения различных типов опасностей (hazards) в процессоре. Эти опасности могут возникать из-за конфликтов в доступе к памяти, из-за изменения потока выполнения программы (например, при выполнении инструкций ветвления или переходов), а также из-за неготовности компонентов к выполнению операций.

#### Устройство
Модуль включает несколько входных сигналов, которые обеспечивают информацию о состоянии процессора, и выходные сигналы, которые указывают на наличие определенных типов опасностей. Основные параметры и сигналы модуля:

- Параметры:
  - `CORE`: номер ядра процессора.
  - `ADDRESS_BITS`: количество бит для адресации памяти.
  - `SCAN_CYCLES_MIN` и `SCAN_CYCLES_MAX`: диапазон циклов для сканирования и отображения информации.
  
- Входные сигналы:
  - `clock`, `reset`: сигналы тактирования и сброса.
  - `fetch_valid`, `fetch_ready`, `issue_request`, `issue_PC`, `fetch_address_in`: сигналы, связанные с выборкой инструкций.
  - `memory_valid`, `memory_ready`: сигналы состояния памяти.
  - `load_memory`, `store_memory`, `load_address`, `memory_address_in`: сигналы загрузки и записи в память.
  - `opcode_decode`, `opcode_execute`, `branch_execute`: коды операций и выполнение ветвления.
  - `scan`: сигнал для сканирования и отображения состояния.

- Выходные сигналы:
  - `i_mem_hazard`: опасность доступа к памяти инструкций.
  - `d_mem_hazard`: опасность доступа к данным памяти.
  - `JALR_branch_hazard`: опасность при выполнении инструкций JALR и ветвлений.
  - `JAL_hazard`: опасность при выполнении инструкции JAL.

#### Логика работы
1. **Обнаружение опасностей доступа к памяти инструкций (`i_mem_hazard`)**:
   - Опасность возникает, если:
     - Память инструкций не готова (`~fetch_ready` и `~issue_request`), или
     - Запрос на выдачу инструкции есть, но память инструкций не готова или адрес не совпадает (`issue_request` и (`~fetch_valid` или `issue_PC != fetch_address_in`)).

2. **Обнаружение опасностей доступа к памяти данных (`d_mem_hazard`)**:
   - Опасность возникает, если:
     - Память данных не готова (`~memory_ready`), или
     - Загрузка данных не завершена (`load_memory` и (`~memory_valid` или `load_address != memory_address_in`)).

3. **Обнаружение опасностей JALR и ветвлений (`JALR_branch_hazard`)**:
   - Опасность возникает, если:
     - В исполнении находится инструкция JALR (`opcode_execute == JALR`), или
     - В исполнении находится инструкция ветвления и она выполнена (`opcode_execute == BRANCH` и `branch_execute`).

4. **Обнаружение опасностей JAL (`JAL_hazard`)**:
   - Опасность возникает, если:
     - В декодировании находится инструкция JAL (`opcode_decode == JAL`).

#### Использование
Этот модуль используется в процессорах для предотвращения выполнения некорректных операций и предотвращения конфликтов при доступе к ресурсам. Когда процессор обнаруживает одну из опасностей, он может принять меры, такие как остановка выполнения, вставка пузырей (NOP) или другие механизмы для корректного выполнения программы.

#### Пример использования
Модуль может быть интегрирован в архитектуру процессора как часть блока управления или интерфейса памяти. Выходные сигналы модуля используются для управления другими частями процессора, чтобы избежать потенциальных конфликтов и обеспечить корректное выполнение программ.


# ------------------------------------------------------------------------------

### Описание модуля `L1_bus_interface`

#### Назначение
Модуль `L1_bus_interface` предназначен для управления взаимодействием между кэшем первого уровня (L1) и общей шиной данных. Этот модуль занимается обработкой запросов кэша и отслеживанием состояний шины, обеспечивая правильный обмен данными между кэшем и другими компонентами системы, такими как процессор и внешняя память.

#### Устройство
Модуль включает множество параметров и сигналов, необходимых для обеспечения корректной работы. Основные параметры и сигналы модуля:

- Параметры:
  - `CACHE_OFFSET_BITS`: максимальное количество битов смещения для кэша.
  - `BUS_OFFSET_BITS`: количество битов для ширины шины.
  - `DATA_WIDTH`: ширина данных.
  - `ADDRESS_WIDTH`: ширина адреса.
  - `MSG_BITS`: количество битов для сообщения.
  - `MAX_OFFSET_BITS`: максимальное количество битов смещения.
  
- Входные сигналы:
  - `clock`, `reset`: сигналы тактирования и сброса.
  - `cache_offset`: текущее значение смещения кэша.
  - `cache_msg_in`, `cache_address_in`, `cache_data_in`: входные данные, адрес и сообщение от кэша.
  - `snoop_msg_in`, `snoop_address_in`, `snoop_data_in`: входные данные, адрес и сообщение для snooping (прослушивания) кэша.
  - `bus_msg_in`, `bus_address_in`, `bus_data_in`: входные данные, адрес и сообщение от шины.
  - `req_ready`: сигнал готовности запроса.
  - `bus_master`: сигнал, указывающий на владение шиной.
  
- Выходные сигналы:
  - `cache_msg_out`, `cache_address_out`, `cache_data_out`: выходные данные, адрес и сообщение для кэша.
  - `snoop_msg_out`, `snoop_address_out`, `snoop_data_out`: выходные данные, адрес и сообщение для snooping кэша.
  - `bus_msg_out`, `bus_address_out`, `bus_data_out`: выходные данные, адрес и сообщение для шины.
  - `active_offset`: активное смещение.

#### Логика работы
Модуль использует конечный автомат (FSM) для управления различными состояниями и переходами между ними. Основные состояния включают:

- `IDLE`: ожидание запроса от кэша или snooping.
- `SNOOPER_REQ`: обработка запроса snooping.
- `CACHE_REQ`: обработка запроса кэша.
- `SN_WAIT_FOR_BUS`, `WAIT_FOR_BUS`: ожидание владения шиной.
- `SN_WAIT_FOR_READY`, `WAIT_RESP`: ожидание готовности запроса.
- `SN_TRANSFER`, `TRANSFER`: передача данных по шине.
- `RECEIVE`: прием данных с шины.
- `WAIT_FOR_SNOOP`, `WAIT_FOR_CACHE`: ожидание завершения операций snooping или кэша.

Логика работы FSM определяется текущим состоянием и входными сигналами. Например, если модуль находится в состоянии `IDLE` и получает запрос от кэша, он переходит в состояние `CACHE_REQ` и начинает обработку этого запроса. Если запрос требует передачи данных по шине, модуль переходит в состояние `WAIT_FOR_BUS`, где ожидает владения шиной перед началом передачи.

#### Использование
Этот модуль используется в процессорах и системах на кристалле (SoC) для обеспечения корректного взаимодействия между кэшем L1 и общей шиной данных. Он управляет передачей данных между кэшем и другими компонентами системы, обеспечивая согласованность данных и корректность выполнения операций.

#### Пример использования
Модуль интегрируется в архитектуру процессора или SoC, обеспечивая взаимодействие кэша L1 с общей шиной данных. Он обрабатывает запросы на чтение и запись данных, а также запросы snooping для обеспечения согласованности данных в многопроцессорных системах. Выходные сигналы модуля используются для управления передачей данных и обеспечивают правильную работу системы в целом.


# ------------------------------------------------------------------------------

### Описание модуля `L1cache_wrapper`

#### Назначение
Модуль `L1cache_wrapper` предназначен для обёртки и координации работы кэша первого уровня (L1), включая контроллер кэша, память кэша, блок snooping (прослушивания) и интерфейс шины. Он управляет всеми аспектами взаимодействия между кэшем, процессором и шиной, обеспечивая корректную работу кэша и эффективное использование шины данных.

#### Устройство
Модуль включает в себя несколько параметров и сигналов, необходимых для работы различных внутренних компонентов. Основные параметры и сигналы модуля:

- Параметры:
  - `STATUS_BITS`, `COHERENCE_BITS`, `CACHE_OFFSET_BITS`, `DATA_WIDTH`, `NUMBER_OF_WAYS`, `ADDRESS_BITS`, `INDEX_BITS`, `MSG_BITS`, `BUS_OFFSET_BITS`, `MAX_OFFSET_BITS`, `REPLACEMENT_MODE`, `CORE`, `CACHE_NO`: параметры, задающие конфигурацию кэша и шины.
  
- Входные сигналы:
  - `clock`, `reset`: сигналы тактирования и сброса.
  - `read`, `write`, `invalidate`, `flush`: сигналы управления кэшированием.
  - `w_byte_en`: сигналы байтовой маски для записи.
  - `address`, `data_in`: адрес и данные для операций чтения/записи.
  - `report`: сигнал для отчётности.
  - `bus_msg_in`, `bus_address_in`, `bus_data_in`: входные данные, адрес и сообщение от шины.
  - `bus_master`, `req_ready`, `curr_offset`: сигналы управления шиной.
  
- Выходные сигналы:
  - `data_out`, `out_address`: выходные данные и адрес.
  - `ready`, `valid`: сигналы готовности и валидности.
  - `bus_msg_out`, `bus_address_out`, `bus_data_out`: выходные данные, адрес и сообщение для шины.
  - `active_offset`: активное смещение.

#### Логика работы
Модуль состоит из нескольких компонентов, работающих совместно для обеспечения функциональности кэша:

1. **Контроллер кэша (`cache_controller`)**:
   - Управляет операциями чтения и записи в кэш.
   - Обрабатывает запросы от процессора и шины.
   - Отвечает за координацию операций snooping и взаимодействие с памятью кэша.

2. **Память кэша (`cache_memory`)**:
   - Хранит данные и метаданные (теги, статус и коды когерентности) для каждой строки кэша.
   - Обеспечивает доступ к данным для операций чтения и записи.
   - Обрабатывает запросы на чтение, запись и инвалидирование.

3. **Блок snooping (`snooper`)**:
   - Обрабатывает запросы snooping для обеспечения когерентности данных в многопроцессорных системах.
   - Отслеживает и управляет состояниями данных в кэше в ответ на операции, инициированные другими процессорами или контроллерами.

4. **Интерфейс шины (`L1_bus_interface`)**:
   - Управляет взаимодействием между кэшем и шиной данных.
   - Обеспечивает передачу данных и сообщений между кэшем и другими компонентами системы.
   - Координирует операции snooping и доступ к шине.

#### Пример использования
Модуль `L1cache_wrapper` используется в архитектуре процессора или системы на кристалле (SoC) для обеспечения эффективного кэширования данных и взаимодействия с общей шиной. Он интегрируется с процессором и другими компонентами системы, обеспечивая оптимальную работу кэша L1 и поддерживая когерентность данных в многопроцессорной среде.

#### Пример взаимодействия
1. Процессор посылает запрос на чтение или запись данных через сигналы `read`, `write`, `address` и `data_in`.
2. Контроллер кэша обрабатывает запрос, определяет, находится ли запрашиваемые данные в кэше, и отправляет соответствующие команды в память кэша.
3. Память кэша возвращает данные или обновляет содержимое, в зависимости от типа запроса.
4. В случае необходимости, интерфейс шины обеспечивает передачу данных между кэшем и внешними устройствами памяти через шину данных.
5. Блок snooping обрабатывает запросы от других процессоров или контроллеров, поддерживая когерентность данных.

Этот модуль является критически важным компонентом для эффективного управления памятью и взаимодействия с шиной данных в современных высокопроизводительных процессорах и системах на кристалле.


# ------------------------------------------------------------------------------

### Описание модуля `LRU`

#### Назначение
Модуль `LRU` (Least Recently Used) реализует политику вытеснения в кэше, которая отслеживает, какие строки кэша были использованы недавно. Когда кэш заполняется, модуль `LRU` помогает определить, какая строка кэша должна быть заменена новой строкой данных.

#### Устройство
Модуль использует двухпортовую память для хранения информации о порядке использования строк кэша. Он принимает на вход текущий индекс и информацию о доступе, обновляя при этом порядок использования строк.

Основные параметры и сигналы модуля:

- Параметры:
  - `WIDTH`: количество строк кэша.
  - `INDEX_BITS`: количество битов для адресации строк кэша.
  
- Входные сигналы:
  - `clock`: тактовый сигнал.
  - `reset`: сигнал сброса.
  - `current_index`: текущий индекс строки кэша.
  - `access`: индекс строки, к которой был произведён доступ.
  - `access_valid`: сигнал, указывающий на валидность доступа.
  
- Выходные сигналы:
  - `lru`: битовая маска, указывающая на строки, которые являются наименее используемыми.

#### Логика работы
1. **Функция `log2`**:
   - Определяет количество битов, необходимых для представления значения в двоичной системе счисления.
   
2. **Параметры и локальные переменные**:
   - `CACHE_DEPTH`: глубина кэша, определяется как 2 в степени `INDEX_BITS`.
   - `LRU_MEM_WIDTH`: ширина памяти для хранения информации о порядке использования строк кэша.

3. **Двухпортовая память (`dual_port_ram_with_pass_through`)**:
   - Порт 0 используется для записи, а порт 1 — для чтения.
   - Инициализация памяти происходит в момент сброса (`reset`).

4. **Обновление порядка использования строк**:
   - При каждом доступе обновляется порядок строк в соответствии с тем, какая строка была использована.
   - Строка, к которой был произведён доступ, получает наименьший приоритет, а остальные строки сдвигаются на одну позицию.

5. **Определение наименее используемой строки (`lru`)**:
   - Строка, которая не была использована дольше всех, получает наивысший приоритет.

#### Использование
Этот модуль используется в кэш-памяти для реализации политики вытеснения `LRU`. Он позволяет определять, какая строка кэша должна быть заменена новой строкой данных, когда кэш заполняется. Это особенно важно в многопроцессорных системах и системах с высокой степенью параллелизма, где оптимизация использования кэша может значительно улучшить производительность.

#### Пример использования
Модуль `LRU` интегрируется в контроллер кэша, который управляет всеми аспектами работы кэша. При каждом доступе к кэшу контроллер обновляет информацию о порядке использования строк, используя модуль `LRU`. Когда кэш заполняется, контроллер использует выходной сигнал `lru` для определения, какая строка кэша должна быть заменена.

Этот модуль является важным компонентом в современных системах на кристалле (SoC) и процессорах, обеспечивая эффективное управление кэш-памятью и улучшая производительность системы в целом.


# ------------------------------------------------------------------------------

### Описание модуля `Lx_bus_interface`

#### Назначение
Модуль `Lx_bus_interface` предназначен для управления взаимодействием между кэшем и шиной данных. Он обеспечивает обмен данными между кэшем и шиной, а также обработку запросов на чтение, запись и другие операции, связанные с когерентностью данных в многопроцессорных системах.

#### Устройство
Модуль включает множество параметров и сигналов, необходимых для корректного выполнения операций. Основные параметры и сигналы модуля:

- Параметры:
  - `CACHE_OFFSET_BITS`: количество битов смещения для кэша.
  - `BUS_OFFSET_BITS`: количество битов для ширины шины.
  - `DATA_WIDTH`: ширина данных.
  - `ADDRESS_WIDTH`: ширина адреса.
  - `MSG_BITS`: количество битов для сообщения.
  - `MAX_OFFSET_BITS`: максимальное количество битов смещения.
  
- Входные сигналы:
  - `clock`, `reset`: сигналы тактирования и сброса.
  - `bus_msg_in`, `bus_address_in`, `bus_data_in`: входные данные, адрес и сообщение от шины.
  - `req_ready`: сигнал готовности запроса.
  - `req_offset`: смещение запроса.
  - `cache_msg_in`, `cache_address_in`, `cache_data_in`: входные данные, адрес и сообщение от кэша.
  
- Выходные сигналы:
  - `bus_msg_out`, `bus_address_out`, `bus_data_out`: выходные данные, адрес и сообщение для шины.
  - `active_offset`: активное смещение.
  - `cache_msg_out`, `cache_address_out`, `cache_data_out`: выходные данные, адрес и сообщение для кэша.

#### Логика работы
1. **Функция `log2`**:
   - Определяет количество битов, необходимых для представления значения в двоичной системе счисления.
   
2. **Параметры и локальные переменные**:
   - `CACHE_WORDS`: количество слов в одной строке кэша.
   - `BUS_WORDS`: ширина шины данных.
   - `MAX_WORDS`: максимальное количество слов.
   - `CACHE_WIDTH`: общая ширина данных кэша.
   - `BUS_WIDTH`: общая ширина данных шины.
   - `CACHE2BUS_OFFSETDIFF`, `CACHE2BUS_RATIO`, `REQ2BUS_OFFSETDIFF`, `REQ2BUS_RATIO`: параметры для преобразования смещений и соотношений между кэшем и шиной.

3. **Основные состояния конечного автомата (FSM)**:
   - `IDLE`: ожидание запроса от кэша или шины.
   - `RECEIVE`: получение данных с шины.
   - `SEND_ADDR`: отправка адреса в кэш.
   - `SEND_TO_CACHE`: отправка данных в кэш.
   - `READ_DATA`: чтение данных из кэша.
   - `READ_FILLER`: заполнение данных для кэша.
   - `TRANSFER`: передача данных по шине.
   - `WAIT_FOR_RESP`: ожидание ответа от кэша.
   - `WAIT_BUS_CLEAR`: ожидание освобождения шины.
   - `WAIT_FLUSH_RESP`: ожидание ответа на операцию очистки (flush).
   - `GET_BUS`: получение владения шиной.

4. **Алгоритм работы FSM**:
   - В состоянии `IDLE` модуль ожидает запросы от кэша или шины.
   - При получении запроса переходит в соответствующее состояние для обработки (например, `RECEIVE`, `SEND_ADDR` и т.д.).
   - Обрабатывает запросы на чтение и запись данных, отправляет и получает данные с шины.
   - Поддерживает операции когерентности данных, такие как `FLUSH` и `WB_REQ`.

5. **Обработка данных и сообщений**:
   - Разделение данных кэша и шины на отдельные слова для удобства обработки.
   - Обновление регистров с данными и сообщениями на основе текущих операций и состояний FSM.

#### Использование
Этот модуль используется в системах на кристалле (SoC) и процессорах для обеспечения эффективного взаимодействия между кэшем и шиной данных. Он управляет всеми аспектами обмена данными и поддержания когерентности данных в многопроцессорных системах.

#### Пример использования
Модуль `Lx_bus_interface` интегрируется с контроллером кэша и другими компонентами системы, обеспечивая корректную работу кэша и эффективное использование шины данных. При этом он обрабатывает различные типы запросов, включая чтение, запись, очистку и другие операции, связанные с когерентностью данных.

Этот модуль является важным компонентом в современных высокопроизводительных процессорах и системах на кристалле, обеспечивая оптимальное взаимодействие между кэшем и шиной данных и поддерживая когерентность данных в многопроцессорной среде.


# ------------------------------------------------------------------------------

### Описание модуля `Lxcache_controller`

#### Назначение
Модуль `Lxcache_controller` предназначен для управления кэш-памятью в системе, обеспечивая обработку запросов на чтение и запись, когерентность данных, а также взаимодействие с внешней памятью или кэшем следующего уровня. Он контролирует все аспекты работы кэша, включая его состояние, метаданные и данные.

#### Устройство
Модуль включает множество параметров и сигналов, необходимых для корректной работы. Основные параметры и сигналы модуля:

- Параметры:
  - `STATUS_BITS`: количество битов для статуса (валидный бит, грязный бит, бит включения).
  - `COHERENCE_BITS`: количество битов для когерентности.
  - `OFFSET_BITS`: количество битов смещения.
  - `DATA_WIDTH`: ширина данных.
  - `NUMBER_OF_WAYS`: количество путей в ассоциативном кэше.
  - `ADDRESS_BITS`: ширина адреса.
  - `INDEX_BITS`: количество битов индекса.
  - `MSG_BITS`: количество битов для сообщения.
  
- Входные сигналы:
  - `clock`, `reset`: сигналы тактирования и сброса.
  - `address`, `data_in`, `msg_in`: входные данные, адрес и сообщение.
  - `report`: сигнал для отчётности.
  - `mem2cache_msg`, `mem2cache_address`, `mem2cache_data`: входные данные, адрес и сообщение от следующего уровня памяти.
  - `data_in0`, `tag_in0`, `matched_way0`, `coh_bits0`, `status_bits0`, `hit0`: входные данные от памяти кэша.

- Выходные сигналы:
  - `data_out`, `out_address`, `msg_out`: выходные данные, адрес и сообщение.
  - `cache2mem_msg`, `cache2mem_address`, `cache2mem_data`: выходные данные, адрес и сообщение к следующему уровню памяти.
  - `read0`, `write0`, `invalidate0`, `index0`, `tag0`, `meta_data0`, `data0`, `way_select0`, `i_reset`: сигналы для управления памятью кэша.

#### Логика работы
1. **Функция `log2`**:
   - Определяет количество битов, необходимых для представления значения в двоичной системе счисления.
   
2. **Параметры и локальные переменные**:
   - `CACHE_WORDS`: количество слов в одной строке кэша.
   - `CACHE_WIDTH`: общая ширина данных кэша.
   - `MBITS`: количество битов для метаданных.
   - `TAG_BITS`: количество битов для тега.
   - `WAY_BITS`: количество битов для выбора пути.
   - `CACHE_DEPTH`: глубина кэша (количество строк).

3. **Основные состояния конечного автомата (FSM)**:
   - `IDLE`: ожидание запроса.
   - `READING`: чтение данных из кэша.
   - `SERVING`: обработка запроса.
   - `RESPOND`: отправка ответа.
   - `WRITE_BACK`: запись данных в память.
   - `READ_STATE`: чтение состояния кэша.
   - `READ_WAIT`: ожидание данных из памяти.
   - `FLUSH_WAIT`: ожидание завершения очистки.
   - `RESET`: сброс состояния.

4. **Алгоритм работы FSM**:
   - В состоянии `IDLE` модуль ожидает запросы от процессора или внешнего устройства.
   - При получении запроса переходит в соответствующее состояние для обработки (например, `READING`, `SERVING` и т.д.).
   - Обрабатывает запросы на чтение и запись данных, отправляет и получает данные от следующего уровня памяти.
   - Поддерживает операции когерентности данных, такие как `FLUSH` и `WB_REQ`.

5. **Обработка данных и сообщений**:
   - Разделение данных на отдельные слова для удобства обработки.
   - Обновление регистров с данными и сообщениями на основе текущих операций и состояний FSM.

#### Использование
Этот модуль используется в системах на кристалле (SoC) и процессорах для обеспечения эффективного управления кэш-памятью. Он управляет всеми аспектами работы кэша, включая обработку запросов на чтение и запись, когерентность данных и взаимодействие с внешней памятью или кэшем следующего уровня.

#### Пример использования
Модуль `Lxcache_controller` интегрируется с памятью кэша и другими компонентами системы, обеспечивая корректную работу кэша и эффективное использование памяти. При этом он обрабатывает различные типы запросов, включая чтение, запись, очистку и другие операции, связанные с когерентностью данных.

Этот модуль является важным компонентом в современных высокопроизводительных процессорах и системах на кристалле, обеспечивая оптимальное управление кэш-памятью и поддерживая когерентность данных в многопроцессорной среде.


# ------------------------------------------------------------------------------

### Описание модуля `Lxcache_wrapper`

#### Назначение
Модуль `Lxcache_wrapper` служит для обертки кэш-контроллера, памяти кэша и интерфейса шины в единую систему, которая может обрабатывать запросы на чтение и запись, управлять когерентностью данных и взаимодействовать с шиной и внешней памятью. Он предоставляет все необходимые интерфейсы для интеграции кэша в более сложные системы на кристалле (SoC).

#### Устройство
Модуль состоит из трех основных компонентов:
1. `Lx_bus_interface`: интерфейс для взаимодействия с шиной.
2. `cache_memory`: память кэша.
3. `Lxcache_controller`: контроллер кэша.

Основные параметры и сигналы модуля:

- Параметры:
  - `STATUS_BITS`: количество битов для статуса.
  - `COHERENCE_BITS`: количество битов для когерентности.
  - `CACHE_OFFSET_BITS`: количество битов смещения для кэша.
  - `DATA_WIDTH`: ширина данных.
  - `NUMBER_OF_WAYS`: количество путей в ассоциативном кэше.
  - `REPLACEMENT_MODE`: режим замены строк в кэше.
  - `ADDRESS_BITS`: ширина адреса.
  - `INDEX_BITS`: количество битов индекса.
  - `MSG_BITS`: количество битов для сообщения.
  - `BUS_OFFSET_BITS`: количество битов для ширины шины.
  - `MAX_OFFSET_BITS`: максимальное количество битов смещения.

- Входные сигналы:
  - `clock`, `reset`: сигналы тактирования и сброса.
  - `address`, `data_in`, `msg_in`: входные данные, адрес и сообщение от шины.
  - `req_ready`, `req_offset`: сигналы готовности и смещения запроса.
  - `report`: сигнал для отчётности.
  - `mem2cache_msg`, `mem2cache_address`, `mem2cache_data`: входные данные, адрес и сообщение от следующего уровня памяти.

- Выходные сигналы:
  - `data_out`, `out_address`, `msg_out`: выходные данные, адрес и сообщение для шины.
  - `active_offset`: активное смещение.
  - `cache2mem_msg`, `cache2mem_address`, `cache2mem_data`: выходные данные, адрес и сообщение для следующего уровня памяти.

#### Логика работы
1. **Функция `log2`**:
   - Определяет количество битов, необходимых для представления значения в двоичной системе счисления.

2. **Параметры и локальные переменные**:
   - `CACHE_WORDS`: количество слов в одной строке кэша.
   - `BUS_WORDS`: ширина шины данных.
   - `CACHE_WIDTH`: общая ширина данных кэша.
   - `BUS_WIDTH`: общая ширина данных шины.
   - `TAG_BITS`: количество битов для тега.
   - `MBITS`: количество битов для метаданных.
   - `WAY_BITS`: количество битов для выбора пути.

3. **Интерфейс шины (`Lx_bus_interface`)**:
   - Обеспечивает обмен данными между кэшем и шиной.
   - Управляет передачей данных, обработкой запросов и когерентностью данных.

4. **Память кэша (`cache_memory`)**:
   - Хранит данные и метаданные (теги, статус и коды когерентности) для каждой строки кэша.
   - Обеспечивает доступ к данным для операций чтения и записи.
   - Поддерживает ассоциативный доступ и политику замены строк.

5. **Контроллер кэша (`Lxcache_controller`)**:
   - Управляет операциями чтения и записи в кэш.
   - Обрабатывает запросы от процессора и шины.
   - Отвечает за координацию операций snooping и взаимодействие с памятью кэша.

#### Использование
Этот модуль используется в системах на кристалле (SoC) и процессорах для обеспечения эффективного управления кэш-памятью. Он управляет всеми аспектами работы кэша, включая обработку запросов на чтение и запись, когерентность данных и взаимодействие с шиной и внешней памятью.

#### Пример использования
Модуль `Lxcache_wrapper` интегрируется с контроллером кэша и памятью кэша, обеспечивая корректную работу кэша и эффективное использование памяти. Он обрабатывает различные типы запросов, включая чтение, запись, очистку и другие операции, связанные с когерентностью данных.

Этот модуль является важным компонентом в современных высокопроизводительных процессорах и системах на кристалле, обеспечивая оптимальное управление кэш-памятью и поддерживая когерентность данных в многопроцессорной среде.


# ------------------------------------------------------------------------------

### Описание модуля `main_memory`

#### Назначение
Модуль `main_memory` представляет собой модель основной памяти (RAM) с несколькими портами, которая обеспечивает хранение данных и обработку запросов на чтение и запись от различных устройств или контроллеров. Основная цель модуля - предоставить интерфейс для взаимодействия с основной памятью, поддерживая несколько портов и обрабатывая запросы на чтение и запись данных.

#### Устройство
Модуль включает несколько параметров и сигналов для настройки и управления основной памятью. Основные параметры и сигналы модуля:

- Параметры:
  - `DATA_WIDTH`: ширина данных.
  - `ADDRESS_WIDTH`: ширина адреса.
  - `MSG_BITS`: количество битов для сообщений.
  - `INDEX_BITS`: количество битов индекса.
  - `NUM_PORTS`: количество портов для обработки запросов.
  - `INIT_FILE`: файл инициализации для загрузки данных в память.

- Входные сигналы:
  - `clock`, `reset`: сигналы тактирования и сброса.
  - `msg_in`: входные сообщения для каждого порта.
  - `address`: входные адреса для каждого порта.
  - `data_in`: входные данные для каждого порта.

- Выходные сигналы:
  - `msg_out`: выходные сообщения для каждого порта.
  - `address_out`: выходные адреса для каждого порта.
  - `data_out`: выходные данные для каждого порта.

#### Логика работы
1. **Функция `log2`**:
   - Определяет количество битов, необходимых для представления значения в двоичной системе счисления.

2. **Параметры и локальные переменные**:
   - `MEM_DEPTH`: глубина памяти (количество строк).
   - `IDLE`, `SERVING`, `READ_OUT`: состояния конечного автомата (FSM).

3. **Основные состояния конечного автомата (FSM)**:
   - `IDLE`: ожидание запросов на чтение или запись.
   - `SERVING`: обработка текущего запроса.
   - `READ_OUT`: завершение чтения и отправка данных.

4. **Разделение входных данных**:
   - Входные данные, адреса и сообщения разбиваются на отдельные порты для обработки.

5. **Arbitration (арбитраж)**:
   - Используется арбитратор для выбора следующего порта, который будет обслуживаться (при наличии нескольких портов).

6. **Контроллер FSM**:
   - Управляет состояниями и переходами между ними для обработки запросов на чтение и запись.
   - Обрабатывает запросы на чтение (`R_REQ`) и запись (`WB_REQ`), обновляя соответствующие выходные сигналы и данные.

7. **Память BRAM**:
   - Используется для хранения данных основной памяти.
   - Обрабатывает операции чтения и записи данных.

#### Использование
Этот модуль используется в системах на кристалле (SoC) и процессорах для обеспечения интерфейса к основной памяти. Он управляет всеми аспектами обмена данными между памятью и другими устройствами или контроллерами, поддерживая многопортовые конфигурации и арбитраж запросов.

#### Пример использования
Модуль `main_memory` может быть интегрирован в архитектуру процессора или SoC для обеспечения эффективного взаимодействия с основной памятью. Он обрабатывает запросы на чтение и запись данных, поддерживает когерентность данных и управляет доступом к памяти с помощью арбитра.

Этот модуль является важным компонентом в современных высокопроизводительных системах на кристалле, обеспечивая надежное и эффективное управление основной памятью и поддерживая многопортовые конфигурации для параллельной обработки данных.


# ------------------------------------------------------------------------------

### Описание модуля `main_memory_interface`

#### Назначение
Модуль `main_memory_interface` предназначен для управления интерфейсом между кэш-памятью, сетью и основной памятью. Он обрабатывает запросы на чтение и запись данных, перенаправляя их к соответствующим модулям, и обеспечивает корректную передачу данных между кэшем и основной памятью или сетью.

#### Устройство
Модуль включает несколько параметров и сигналов для настройки и управления интерфейсом памяти. Основные параметры и сигналы модуля:

- Параметры:
  - `OFFSET_BITS`: количество битов смещения.
  - `DATA_WIDTH`: ширина данных.
  - `ADDRESS_WIDTH`: ширина адреса.
  - `MSG_BITS`: количество битов для сообщений.

- Входные сигналы:
  - `clock`, `reset`: сигналы тактирования и сброса.
  - `cache2interface_msg`, `cache2interface_address`, `cache2interface_data`: входные сообщения, адреса и данные от кэш-памяти.
  - `network2interface_msg`, `network2interface_address`, `network2interface_data`: входные сообщения, адреса и данные от сети.
  - `mem2interface_msg`, `mem2interface_address`, `mem2interface_data`: входные сообщения, адреса и данные от основной памяти.

- Выходные сигналы:
  - `interface2cache_msg`, `interface2cache_address`, `interface2cache_data`: выходные сообщения, адреса и данные для кэш-памяти.
  - `interface2network_msg`, `interface2network_address`, `interface2network_data`: выходные сообщения, адреса и данные для сети.
  - `interface2mem_msg`, `interface2mem_address`, `interface2mem_data`: выходные сообщения, адреса и данные для основной памяти.

#### Логика работы
1. **Параметры и локальные переменные**:
   - `WORDS_PER_LINE`: количество слов в одной линии кэша.
   - `BUS_WIDTH`: общая ширина данных на шине.
   - `IDLE`, `READ_MEMORY`, `WRITE_MEMORY`, `RESPOND`: состояния конечного автомата (FSM).

2. **Основные состояния конечного автомата (FSM)**:
   - `IDLE`: ожидание запросов от кэш-памяти.
   - `READ_MEMORY`: чтение данных из основной памяти.
   - `WRITE_MEMORY`: запись данных в основную память.
   - `RESPOND`: отправка ответа кэш-памяти.

3. **Разделение входных данных**:
   - Входные данные, адреса и сообщения разбиваются на отдельные слова для обработки.

4. **Определение локального адреса**:
   - В данном случае `local_address` всегда равен 1 (временное значение, необходимо доработать логику для поддержки распределенной памяти).

5. **Контроллер FSM**:
   - Управляет состояниями и переходами между ними для обработки запросов на чтение и запись.
   - Обрабатывает запросы на чтение (`R_REQ`) и запись (`WB_REQ`), обновляя соответствующие выходные сигналы и данные.
   - В состоянии `READ_MEMORY` считывает данные из основной памяти и передает их кэш-памяти.
   - В состоянии `WRITE_MEMORY` записывает данные из кэш-памяти в основную память.
   - В состоянии `RESPOND` отправляет ответ кэш-памяти.

#### Использование
Этот модуль используется в системах на кристалле (SoC) и процессорах для обеспечения интерфейса между кэш-памятью, сетью и основной памятью. Он управляет всеми аспектами обмена данными между этими компонентами, поддерживая корректную передачу данных и обработку запросов на чтение и запись.

#### Пример использования
Модуль `main_memory_interface` может быть интегрирован в архитектуру процессора или SoC для обеспечения эффективного взаимодействия между кэш-памятью и основной памятью или сетью. Он обрабатывает запросы на чтение и запись данных, поддерживает когерентность данных и управляет доступом к памяти с помощью арбитра.

Этот модуль является важным компонентом в современных высокопроизводительных системах на кристалле, обеспечивая надежное и эффективное управление основной памятью и поддерживая многопортовые конфигурации для параллельной обработки данных.


# ------------------------------------------------------------------------------

### Описание модуля `memory_interface`

#### Назначение
Модуль `memory_interface` служит для интерфейса между различными стадиями процессора (fetch и memory) и кэш-памятью/основной памятью. Он обеспечивает передачу данных и управление сигналами между этими компонентами, обеспечивая синхронизацию и правильное выполнение операций чтения и записи.

#### Устройство
Модуль имеет несколько параметров и сигналов для настройки и управления интерфейсом памяти. Основные параметры и сигналы модуля:

- Параметры:
  - `DATA_WIDTH`: ширина данных.
  - `ADDRESS_BITS`: ширина адреса.

- Входные сигналы:
  - `fetch_read`: сигнал чтения для стадии fetch.
  - `fetch_address_out`: выходной адрес для стадии fetch.
  - `memory_read`: сигнал чтения для стадии memory.
  - `memory_write`: сигнал записи для стадии memory.
  - `memory_byte_en`: байтовые маски для записи данных.
  - `memory_address_out`: выходной адрес для стадии memory.
  - `memory_data_out`: данные для записи на стадии memory.
  - `i_mem_data_out`: выходные данные из кэша инструкций.
  - `i_mem_address_out`: выходной адрес из кэша инструкций.
  - `i_mem_valid`: сигнал валидности данных из кэша инструкций.
  - `i_mem_ready`: сигнал готовности кэша инструкций.
  - `d_mem_data_out`: выходные данные из кэша данных.
  - `d_mem_address_out`: выходной адрес из кэша данных.
  - `d_mem_valid`: сигнал валидности данных из кэша данных.
  - `d_mem_ready`: сигнал готовности кэша данных.
  - `scan`: сигнал для режима сканирования (тестирования).

- Выходные сигналы:
  - `fetch_data_in`: входные данные для стадии fetch.
  - `fetch_address_in`: входной адрес для стадии fetch.
  - `fetch_valid`: сигнал валидности данных для стадии fetch.
  - `fetch_ready`: сигнал готовности для стадии fetch.
  - `memory_data_in`: входные данные для стадии memory.
  - `memory_address_in`: входной адрес для стадии memory.
  - `memory_valid`: сигнал валидности данных для стадии memory.
  - `memory_ready`: сигнал готовности для стадии memory.
  - `i_mem_read`: сигнал чтения для кэша инструкций.
  - `i_mem_address_in`: входной адрес для кэша инструкций.
  - `d_mem_read`: сигнал чтения для кэша данных.
  - `d_mem_write`: сигнал записи для кэша данных.
  - `d_mem_byte_en`: байтовые маски для кэша данных.
  - `d_mem_address_in`: входной адрес для кэша данных.
  - `d_mem_data_in`: входные данные для кэша данных.

#### Логика работы
Модуль `memory_interface` связывает сигналы между стадиями fetch и memory процессора и кэшем инструкций и данных. Логика работы заключается в следующем:

1. **Fetch Stage**:
   - Принимает сигнал чтения `fetch_read` и адрес `fetch_address_out`.
   - Передает данные из кэша инструкций `i_mem_data_out` и адрес `i_mem_address_out` обратно в стадию fetch через `fetch_data_in` и `fetch_address_in`.
   - Передает сигналы валидности и готовности из кэша инструкций (`i_mem_valid`, `i_mem_ready`) на стадию fetch (`fetch_valid`, `fetch_ready`).

2. **Memory Stage**:
   - Принимает сигналы чтения и записи (`memory_read`, `memory_write`), байтовые маски (`memory_byte_en`), адрес (`memory_address_out`) и данные (`memory_data_out`).
   - Передает данные из кэша данных `d_mem_data_out` и адрес `d_mem_address_out` обратно в стадию memory через `memory_data_in` и `memory_address_in`.
   - Передает сигналы валидности и готовности из кэша данных (`d_mem_valid`, `d_mem_ready`) на стадию memory (`memory_valid`, `memory_ready`).

3. **Кэш инструкций**:
   - Принимает сигнал чтения и адрес от стадии fetch (`fetch_read`, `fetch_address_out`) и передает их в кэш инструкций (`i_mem_read`, `i_mem_address_in`).

4. **Кэш данных**:
   - Принимает сигналы чтения и записи, байтовые маски, адрес и данные от стадии memory (`memory_read`, `memory_write`, `memory_byte_en`, `memory_address_out`, `memory_data_out`) и передает их в кэш данных (`d_mem_read`, `d_mem_write`, `d_mem_byte_en`, `d_mem_address_in`, `d_mem_data_in`).

#### Использование
Этот модуль используется в процессорах и системах на кристалле (SoC) для обеспечения интерфейса между стадиями процессора и кэш-памятью/основной памятью. Он управляет всеми аспектами обмена данными между этими компонентами, обеспечивая синхронизацию и правильное выполнение операций чтения и записи.

#### Пример использования
Модуль `memory_interface` может быть интегрирован в архитектуру процессора или SoC для обеспечения эффективного взаимодействия между стадиями процессора и кэш-памятью. Он обрабатывает запросы на чтение и запись данных, поддерживает когерентность данных и управляет доступом к памяти.

Этот модуль является важным компонентом в современных высокопроизводительных системах на кристалле, обеспечивая надежное и эффективное управление кэш-памятью и поддерживая многопортовые конфигурации для параллельной обработки данных.


# ------------------------------------------------------------------------------

Модуль `memory_issue` предназначен для управления операциями чтения и записи в памяти в процессе выполнения инструкций процессора. Он обеспечивает интерфейс между стадией выполнения инструкций (execute stage) и памятью, определяя, какие байты должны быть прочитаны или записаны, и обеспечивая правильную адресацию и формат данных.

### Зачем он нужен

Модуль используется для реализации операций загрузки (load) и записи (store) данных в память, обеспечивая корректное выравнивание данных и управление доступом к различным байтам памяти.

### Как устроен

Модуль включает в себя следующие основные компоненты и функции:

1. **Параметры:**
   - `CORE`, `DATA_WIDTH`, `ADDRESS_BITS`, `NUM_BYTES`, `LOG2_NUM_BYTES`, `SCAN_CYCLES_MIN`, `SCAN_CYCLES_MAX` - параметры, определяющие конфигурацию модуля, такие как ширина данных, количество адресных битов и параметры для сканирования.

2. **Входные сигналы:**
   - `clock`, `reset` - сигналы тактирования и сброса.
   - `load`, `store` - сигналы, указывающие на выполнение операций чтения или записи.
   - `address` - адрес памяти для операций.
   - `store_data` - данные для записи в память.
   - `log2_bytes` - логарифм по основанию 2 от количества байтов, используемых в операции.

3. **Выходные сигналы:**
   - `memory_read`, `memory_write` - сигналы чтения и записи в память.
   - `memory_byte_en` - маска байтов для операций записи.
   - `memory_address` - адрес памяти для операций.
   - `memory_data` - данные для записи в память.

4. **Вспомогательные провода и регистры:**
   - `base_byte`, `mux_chain`, `byte_en_mask` - провода для кодирования байтов и масок байтов.
   - `byte_data`, `half_word_data` - провода для данных байта и полуслов.

### Логика работы

1. **Функция log2:**
   Определяет логарифм по основанию 2 от входного значения для вычисления `LOG2_NUM_BYTES`.

2. **Базовый декодер байтов (BASE_BYTE_DECODER):**
   Использует цепочку мультиплексоров для декодирования младшего значащего байта в слове, которое будет записано.

3. **Маскирование байтов:**
   Создаются маски для каждой возможной записи, чтобы можно было записывать байты, полуслова и слова в невыравненные адреса.

4. **Формирование данных для памяти:**
   Данные для памяти формируются в зависимости от количества байтов, определенного в `log2_bytes`.

5. **Управление операциями чтения и записи:**
   Сигналы `memory_read` и `memory_write` активируются в зависимости от сигналов `load` и `store`.

6. **Отображение информации для сканирования:**
   Использует регистр `cycles` для отслеживания циклов и отображения информации о текущей операции, если активирован режим сканирования.

7. **Проверка выравнивания адресов:**
   Отображает сообщения о невыравненных операциях чтения и записи.

### Как используется

Этот модуль используется в процессоре для обеспечения корректных операций чтения и записи в память. Он гарантирует правильное выравнивание данных и корректное управление байтами, что важно для эффективной и безопасной работы процессора. Модуль интегрируется в более крупные архитектуры процессора, обрабатывающие этапы выполнения инструкций и взаимодействующие с памятью.


# ------------------------------------------------------------------------------

Модуль `memory_receive` предназначен для обработки данных, загружаемых из памяти, и их корректного преобразования в зависимости от типа загрузки (подписанные или неподписанные данные, байты, полуслова и слова). Этот модуль является частью интерфейса между памятью и этапом записи (writeback) в процессоре.

### Зачем он нужен

Модуль используется для декодирования и обработки данных, поступающих из памяти, в зависимости от типа загрузки (например, загрузка байта, полуслова или слова) и их корректного выравнивания. Это необходимо для правильной работы операций загрузки данных в процессоре.

### Как устроен

Модуль включает в себя следующие основные компоненты и функции:

1. **Параметры:**
   - `CORE`, `DATA_WIDTH`, `ADDRESS_BITS`, `NUM_BYTES`, `LOG2_NUM_BYTES`, `SCAN_CYCLES_MIN`, `SCAN_CYCLES_MAX` - параметры, определяющие конфигурацию модуля, такие как ширина данных и количество адресных битов.

2. **Входные сигналы:**
   - `clock`, `reset` - сигналы тактирования и сброса.
   - `log2_bytes` - логарифм по основанию 2 от количества байтов, используемых в операции загрузки.
   - `unsigned_load` - сигнал, указывающий на неподписанную загрузку.
   - `memory_data_in` - данные, поступающие из памяти.
   - `memory_address_in` - адрес данных в памяти.

3. **Выходные сигналы:**
   - `load_data` - данные, готовые для записи на этапе writeback.

4. **Вспомогательные провода и регистры:**
   - `load_type`, `byte_shift`, `shifted_data` - провода для управления типом загрузки, сдвигом байтов и преобразованными данными.

### Логика работы

1. **Функция log2:**
   Определяет логарифм по основанию 2 от входного значения для вычисления `LOG2_NUM_BYTES`.

2. **Определение типа загрузки:**
   - `load_type` формируется из `log2_bytes` и `unsigned_load` для определения типа загрузки данных.

3. **Сдвиг данных:**
   - `byte_shift` вычисляется на основе младших битов адреса памяти.
   - `shifted_data` - данные из памяти сдвигаются в зависимости от `byte_shift`.

4. **Формирование данных для записи:**
   В зависимости от типа загрузки (`load_type`), данные формируются следующим образом:
   - Загрузка байта (LB или LBU).
   - Загрузка полуслова (LH или LHU).
   - Загрузка слова (LW или LWU).

5. **Отображение информации для сканирования:**
   Использует регистр `cycles` для отслеживания циклов и отображения информации о текущей операции, если активирован режим сканирования.

### Как используется

Этот модуль используется в процессоре для обработки данных, загружаемых из памяти, и подготовки их для этапа записи (writeback). Он гарантирует правильное преобразование и выравнивание данных в зависимости от типа загрузки (подписанные или неподписанные данные) и ширины данных (байты, полуслова, слова). Модуль интегрируется в архитектуру процессора, обеспечивая корректную работу операций загрузки данных.


# ------------------------------------------------------------------------------

Модуль `mux_bus` представляет собой мультиплексор, который позволяет выбрать один из нескольких входных портов и передать его данные на выход. Этот модуль используется в цифровых системах для маршрутизации данных из разных источников к одному выходу, в зависимости от управляющего сигнала.

### Зачем он нужен

Мультиплексор необходим для выбора одного из множества входных сигналов и передачи выбранного сигнала на выход. В контексте процессора, такой модуль может использоваться для маршрутизации данных между различными модулями или компонентами системы, обеспечивая гибкость и управляемость потоков данных.

### Как устроен

Модуль `mux_bus` включает в себя следующие основные компоненты и функции:

1. **Параметры:**
   - `WIDTH` - ширина каждого входного порта данных.
   - `NUM_PORTS` - количество входных портов.

2. **Входные сигналы:**
   - `data_in` - вектор данных, содержащий данные всех входных портов.
   - `enable_port` - сигнал выбора порта, определяющий, какой из входных портов будет передан на выход.
   - `valid_enable` - сигнал, указывающий на валидность выбора порта.

3. **Выходные сигналы:**
   - `data_out` - данные выбранного входного порта.

4. **Вспомогательные провода:**
   - `inputs` - массив проводов, представляющих отдельные входные порты.

### Логика работы

1. **Функция log2:**
   Определяет логарифм по основанию 2 от входного значения для вычисления количества битов, необходимых для кодирования числа портов.

2. **Генерация массивов входных данных:**
   Используя параметр `NUM_PORTS`, модуль разбивает входной вектор `data_in` на отдельные порты данных, каждый шириной `WIDTH` бит.

3. **Мультиплексирование данных:**
   В зависимости от значения `enable_port` и сигнала `valid_enable`, модуль выбирает один из входных портов и передает его данные на выход `data_out`. Если `valid_enable` неактивен, на выход подается нулевое значение.

### Как используется

Модуль `mux_bus` используется в различных цифровых системах и процессорах для маршрутизации данных между разными компонентами. Примеры использования включают:

- Переключение между различными источниками данных, такими как регистры, память или порты ввода-вывода.
- Объединение данных из нескольких источников в одном модуле для последующей обработки.
- Управление потоками данных в мультипроцессорных системах или системах на кристалле (SoC).

### Пример использования

Допустим, у нас есть четыре различных источника данных, каждый шириной 8 бит, и мы хотим выбрать один из них для передачи на выход:

```verilog
module test_mux;
  reg [31:0] data_in;
  reg [1:0] enable_port;
  reg valid_enable;
  wire [7:0] data_out;

  mux_bus #(.WIDTH(8), .NUM_PORTS(4)) my_mux (
    .data_in(data_in),
    .enable_port(enable_port),
    .valid_enable(valid_enable),
    .data_out(data_out)
  );

  initial begin
    // Инициализация данных
    data_in = 32'hAABBCCDD;
    enable_port = 2'b01;
    valid_enable = 1'b1;
    
    // Ожидаемый выход: 8'hCC (второй байт данных)
    #10;
    $display("Selected data: %h", data_out);
  end
endmodule
```

В этом примере `data_in` содержит четыре байта данных, и в зависимости от значения `enable_port`, один из байтов будет передан на выход `data_out`.


# ------------------------------------------------------------------------------

Модуль `one_hot_decoder` предназначен для декодирования одноразрядного (one-hot) кода в бинарное представление. Он используется для преобразования входного одноразрядного кода в компактное двоичное представление, а также для проверки валидности кода (т.е. проверка, что один и только один бит в коде установлен в 1).

### Зачем он нужен

Этот модуль используется в цифровых системах для обработки одноразрядных кодов, которые часто применяются для кодирования состояний, выбора одного из нескольких сигналов и других целей. Декодирование одноразрядного кода позволяет получить его позицию в бинарном виде, что может быть полезно для дальнейшей обработки.

### Как устроен

Модуль включает в себя следующие компоненты и функции:

1. **Параметры:**
   - `WIDTH` - ширина входного одноразрядного кода.

2. **Входные сигналы:**
   - `encoded` - одноразрядный код шириной `WIDTH` бит.

3. **Выходные сигналы:**
   - `decoded` - двоичный код, представляющий позицию установленного бита в одноразрядном коде.
   - `valid` - сигнал, указывающий на валидность входного кода (установлен ровно один бит).

4. **Вспомогательные сигналы и модули:**
   - `decoded_half_valid`, `top_half_has_one` - промежуточные сигналы для проверки наличия установленного бита в половине ширины кода.
   - Рекурсивное использование модуля `one_hot_decoder` для декодирования половины входного кода.

### Логика работы

1. **Функция log2:**
   Определяет логарифм по основанию 2 от входного значения для вычисления ширины выходного двоичного кода.

2. **Генерация и рекурсия:**
   - Если ширина входного кода равна 2, то модуль напрямую декодирует одноразрядный код.
   - В противном случае, входной код делится на две половины, и проверяется наличие установленного бита в верхней половине.
   - Если бит установлен в верхней половине, то декодируется верхняя половина, иначе декодируется нижняя половина.
   - Процесс декодирования продолжается рекурсивно, пока ширина входного кода не станет равной 2.

### Пример использования

Допустим, у нас есть 16-битный одноразрядный код, и мы хотим получить его позицию в двоичном виде:

```verilog
module test_one_hot_decoder;
  reg [15:0] encoded;
  wire [3:0] decoded;
  wire valid;

  one_hot_decoder #(.WIDTH(16)) my_decoder (
    .encoded(encoded),
    .decoded(decoded),
    .valid(valid)
  );

  initial begin
    // Пример: кодирует позицию 5 (начиная с 0)
    encoded = 16'b0000000010000000;
    #10;
    $display("Encoded: %b, Decoded: %d, Valid: %b", encoded, decoded, valid);
    
    // Пример: невалидный код (больше одного бита установлено)
    encoded = 16'b0000000010000010;
    #10;
    $display("Encoded: %b, Decoded: %d, Valid: %b", encoded, decoded, valid);
  end
endmodule
```

В этом примере модуль `one_hot_decoder` декодирует 16-битный одноразрядный код, проверяет его валидность и выдает позицию установленного бита в двоичном виде. Если код невалидный (установлено больше одного бита), сигнал `valid` будет установлен в 0.


# ------------------------------------------------------------------------------

Модуль `one_hot_encoder` предназначен для преобразования двоичного входного значения в одноразрядный (one-hot) код. Этот модуль используется в цифровых системах для представления позиции двоичного числа в виде одноразрядного кода, где только один бит установлен в 1, а остальные биты установлены в 0.

### Зачем он нужен

Этот модуль используется для кодирования позиции двоичного числа в одноразрядный код, который часто применяется для выбора конкретного элемента из множества, управления состояниями в конечных автоматах, и в других случаях, где необходимо однозначно идентифицировать один из нескольких возможных вариантов.

### Как устроен

Модуль включает в себя следующие компоненты и функции:

1. **Параметры:**
   - `WIDTH` - ширина выходного одноразрядного кода.

2. **Входные сигналы:**
   - `in` - двоичное входное значение, представляющее позицию, которая будет закодирована в одноразрядный код.
   - `valid_input` - сигнал, указывающий на валидность входного значения.

3. **Выходные сигналы:**
   - `out` - выходной одноразрядный код шириной `WIDTH` бит.

### Логика работы

1. **Функция log2:**
   Определяет логарифм по основанию 2 от входного значения для вычисления количества битов, необходимых для кодирования позиции.

2. **Генерация одноразрядного кода:**
   - Используя параметр `WIDTH`, модуль создает одноразрядный код на основе входного значения `in`.
   - Каждый бит выходного кода `out` устанавливается в 1, если значение `in` совпадает с индексом этого бита, и `valid_input` активно. В противном случае бит устанавливается в 0.

### Пример использования

Допустим, у нас есть 3-битное двоичное число, и мы хотим закодировать его позицию в 8-битный одноразрядный код:

```verilog
module test_one_hot_encoder;
  reg [2:0] in;
  reg valid_input;
  wire [7:0] out;

  one_hot_encoder #(.WIDTH(8)) my_encoder (
    .in(in),
    .valid_input(valid_input),
    .out(out)
  );

  initial begin
    // Пример: кодирует позицию 3
    in = 3'b011;
    valid_input = 1'b1;
    #10;
    $display("Input: %b, One-hot Encoded: %b", in, out);
    
    // Пример: невалидный ввод (valid_input = 0)
    in = 3'b010;
    valid_input = 1'b0;
    #10;
    $display("Input: %b, One-hot Encoded: %b", in, out);
  end
endmodule
```

В этом примере модуль `one_hot_encoder` преобразует 3-битное двоичное число в 8-битный одноразрядный код. Если входное значение валидно (`valid_input` = 1), то соответствующий бит в выходном коде устанавливается в 1. Если входное значение невалидно (`valid_input` = 0), то все биты выходного кода устанавливаются в 0.

### Заключение

Модуль `one_hot_encoder` является полезным компонентом для преобразования двоичного числа в одноразрядный код, что может быть полезно в различных цифровых системах и приложениях. Он обеспечивает простое и эффективное решение для кодирования позиций, которые можно использовать для управления состояниями и выбора сигналов.


# ------------------------------------------------------------------------------

Файл `params.h` содержит определения параметров, используемых в модуле для шины и управления когерентностью кэша. Эти параметры являются локальными и, как правило, используются для кодирования различных состояний и сообщений в системе.

### Зачем он нужен

Этот файл нужен для централизованного определения и упрощения использования констант, которые используются в разных модулях системы. Такие параметры позволяют легче изменять и поддерживать код, поскольку любые изменения этих констант автоматически применяются ко всем модулям, которые их используют.

### Как устроен

Файл состоит из двух основных секций:

1. **Сообщения шины (bus messages):**
   Эти константы используются для кодирования различных типов запросов и ответов, которые могут передаваться по шине.

2. **Состояния когерентности (coherence states):**
   Эти константы используются для определения состояний когерентности кэша.

### Параметры сообщений шины

- `NO_REQ` (0): Нет запроса.
- `R_REQ` (1): Запрос на чтение.
- `WB_REQ` (2): Запрос на запись (write-back).
- `FLUSH` (3): Очистка.
- `FLUSH_S` (4): Очистка, сохранение.
- `WS_BCAST` (5): Широковещательная передача состояния записи.
- `RFO_BCAST` (6): Широковещательная передача состояния чтения для записи (Read For Ownership).
- `C_WB` (7): Кэшированная запись.
- `C_FLUSH` (8): Кэшированная очистка.
- `EN_ACCESS` (9): Включение доступа.
- `MEM_RESP` (10): Ответ памяти.
- `MEM_RESP_S` (11): Ответ памяти, сохранение.
- `MEM_C_RESP` (12): Ответ памяти с проверкой.
- `REQ_FLUSH` (13): Запрос на очистку.
- `HOLD_BUS` (14): Удержание шины.

### Параметры состояний когерентности

- `INVALID` (00): Неверное состояние.
- `EXCLUSIVE` (01): Эксклюзивное состояние.
- `SHARED` (11): Разделенное состояние.
- `MODIFIED` (10): Модифицированное состояние.

### Пример использования

Предположим, у нас есть модуль, который обрабатывает сообщения шины и управляет состояниями когерентности кэша. Этот модуль может использовать параметры, определенные в `params.h`, для принятия решений и выполнения соответствующих действий.

```verilog
module cache_controller(
  input [3:0] bus_message,
  input [1:0] current_state,
  output reg [1:0] next_state
);

  always @(*) begin
    case (bus_message)
      R_REQ: begin
        if (current_state == INVALID) begin
          next_state = EXCLUSIVE;
        end else if (current_state == SHARED) begin
          next_state = SHARED;
        end
      end
      WB_REQ: begin
        if (current_state == EXCLUSIVE || current_state == SHARED) begin
          next_state = MODIFIED;
        end
      end
      FLUSH: begin
        next_state = INVALID;
      end
      default: begin
        next_state = current_state;
      end
    endcase
  end
endmodule
```

В этом примере модуль `cache_controller` использует параметры сообщений шины и состояний когерентности для определения следующего состояния кэша на основе текущего состояния и полученного сообщения. Это позволяет легко понимать и поддерживать логику управления состояниями кэша.


# ------------------------------------------------------------------------------

Модуль `pipeline_register` предназначен для реализации регистров конвейера (pipeline registers) в процессоре. Такие регистры используются для хранения промежуточных данных между различными стадиями конвейера, обеспечивая правильное выполнение инструкций и управление данными.

### Зачем он нужен

В процессоре, построенном по конвейерному принципу, инструкции выполняются в несколько этапов, проходя через разные стадии конвейера. Регистры конвейера необходимы для хранения данных, промежуточных результатов и состояний между этими стадиями. Это позволяет разделять выполнение инструкций на отдельные этапы и повышать общую производительность процессора.

### Как устроен

Модуль `pipeline_register` включает в себя следующие основные компоненты и функции:

1. **Параметры:**
   - `PIPELINE_STAGE` - номер стадии конвейера, для которой предназначен данный регистр.
   - `PIPE_WIDTH` - ширина регистра конвейера.
   - `SCAN_CYCLES_MIN` и `SCAN_CYCLES_MAX` - параметры для сканирования, определяющие диапазон циклов для отображения данных (если активировано сканирование).

2. **Входные сигналы:**
   - `clock` - тактовый сигнал.
   - `reset` - сигнал сброса.
   - `stall` - сигнал остановки, указывающий, что регистр должен сохранить текущее значение.
   - `flush` - сигнал очистки, указывающий, что регистр должен принять значение `flush_input`.
   - `pipe_input` - входные данные для регистра.
   - `flush_input` - данные для загрузки в регистр при активации сигнала очистки.
   - `scan` - сигнал сканирования для отображения состояния регистра.

3. **Выходные сигналы:**
   - `pipe_output` - выходные данные регистра.

4. **Внутренние регистры:**
   - `pipe_reg` - регистр для хранения данных.

### Логика работы

1. **Процесс обновления регистра:**
   - При активном сигнале сброса (`reset`), регистр устанавливается в нулевое значение.
   - При активном сигнале очистки (`flush`), регистр устанавливается в значение `flush_input`.
   - При активном сигнале остановки (`stall`), регистр сохраняет свое текущее значение.
   - В противном случае, регистр обновляется значением `pipe_input`.

2. **Вывод данных:**
   - Выходной сигнал `pipe_output` принимает значение регистра `pipe_reg`.

### Пример использования

Предположим, у нас есть простой процессор с тремя стадиями конвейера: выборка инструкции (fetch), декодирование инструкции (decode) и выполнение инструкции (execute). Мы можем использовать регистры конвейера для хранения промежуточных данных между этими стадиями.

```verilog
module simple_processor(
  input clock,
  input reset,
  input [31:0] instruction,
  output [31:0] result
);

  wire [31:0] fetch_decode;
  wire [31:0] decode_execute;

  // Fetch-Decode pipeline register
  pipeline_register #(.PIPE_WIDTH(32)) fetch_decode_reg (
    .clock(clock),
    .reset(reset),
    .stall(1'b0),
    .flush(1'b0),
    .pipe_input(instruction),
    .flush_input(32'b0),
    .pipe_output(fetch_decode)
  );

  // Decode-Execute pipeline register
  pipeline_register #(.PIPE_WIDTH(32)) decode_execute_reg (
    .clock(clock),
    .reset(reset),
    .stall(1'b0),
    .flush(1'b0),
    .pipe_input(fetch_decode),
    .flush_input(32'b0),
    .pipe_output(decode_execute)
  );

  // Simple execution logic
  assign result = decode_execute + 1;

endmodule
```

В этом примере используется два регистра конвейера для хранения данных между стадиями выборки, декодирования и выполнения инструкций. Первый регистр `fetch_decode_reg` принимает инструкцию и передает ее на стадию декодирования. Второй регистр `decode_execute_reg` принимает декодированную инструкцию и передает ее на стадию выполнения, где производится простая операция (прибавление 1 к значению).

### Заключение

Модуль `pipeline_register` является важным компонентом конвейерной архитектуры процессора. Он позволяет эффективно управлять потоками данных между стадиями конвейера, обеспечивая корректное выполнение инструкций и повышая общую производительность системы.


# ------------------------------------------------------------------------------

Модуль `priority_encoder` предназначен для реализации приоритетного кодера, который принимает одноразрядный (one-hot) код на входе и преобразует его в двоичный код. Этот модуль учитывает приоритет битов на входе, позволяя выбрать между приоритетом старшего разряда (MSB) или младшего разряда (LSB).

### Зачем он нужен

Приоритетные кодеры используются в цифровых системах для определения позиции самого значимого установленного бита в одном из входных сигналов. Это полезно в схемах арбитража, в которых нужно определить, какой из нескольких запросов должен быть обработан первым.

### Как устроен

Модуль `priority_encoder` включает в себя следующие компоненты и функции:

1. **Параметры:**
   - `WIDTH` - ширина входного сигнала.
   - `PRIORITY` - параметр, определяющий приоритет (MSB или LSB).

2. **Входные сигналы:**
   - `decode` - входной одноразрядный код шириной `WIDTH` бит.

3. **Выходные сигналы:**
   - `encode` - двоичный код, представляющий позицию самого значимого установленного бита.
   - `valid` - сигнал, указывающий на валидность входного кода (наличие установленного бита).

### Логика работы

1. **Функция log2:**
   Определяет логарифм по основанию 2 от входного значения для вычисления количества битов, необходимых для кодирования позиции.

2. **Генерация и рекурсия:**
   - Если ширина входного сигнала равна 2, то модуль напрямую кодирует одноразрядный код, в зависимости от приоритета.
   - В противном случае, входной код делится на две половины, и проверяется наличие установленного бита в одной из половин в зависимости от приоритета.
   - Рекурсивное использование модуля `priority_encoder` для кодирования половины входного кода продолжается до тех пор, пока ширина не станет равной 2.

### Пример использования

Допустим, у нас есть 8-битный одноразрядный код, и мы хотим закодировать его позицию в 3-битный двоичный код с приоритетом старшего разряда (MSB):

```verilog
module test_priority_encoder;
  reg [7:0] decode;
  wire [2:0] encode;
  wire valid;

  priority_encoder #(.WIDTH(8), .PRIORITY("MSB")) my_encoder (
    .decode(decode),
    .encode(encode),
    .valid(valid)
  );

  initial begin
    // Пример: кодирует позицию 5 (начиная с 0)
    decode = 8'b00100000;
    #10;
    $display("Decode: %b, Encode: %b, Valid: %b", decode, encode, valid);
    
    // Пример: невалидный код (все нули)
    decode = 8'b00000000;
    #10;
    $display("Decode: %b, Encode: %b, Valid: %b", decode, encode, valid);
  end
endmodule
```

В этом примере модуль `priority_encoder` преобразует 8-битный одноразрядный код в 3-битный двоичный код с приоритетом старшего разряда (MSB). Если входной сигнал содержит установленный бит, выходной сигнал `encode` указывает позицию самого значимого установленного бита, а сигнал `valid` становится активным. Если входной сигнал не содержит установленных битов, сигнал `valid` остается неактивным.

### Заключение

Модуль `priority_encoder` является важным компонентом для реализации приоритетного кодирования в цифровых системах. Он обеспечивает эффективное и гибкое решение для определения позиции самого значимого установленного бита, что может быть полезно в схемах арбитража и управления запросами.


# ------------------------------------------------------------------------------

Модуль `Processor_v4` представляет собой многопроцессорную систему на одном кристалле (SoC), включающую в себя несколько ядер, интерфейс памяти и иерархию кэшей. Он реализует взаимодействие между этими компонентами для выполнения инструкций и обработки данных. Рассмотрим его структуру и работу подробнее.

### Зачем он нужен

Этот модуль реализует многопроцессорную систему, состоящую из нескольких ядер процессоров, которые могут одновременно выполнять разные задачи, взаимодействовать с памятью и кэшами. Такая архитектура позволяет увеличить производительность и гибкость системы за счет параллельного выполнения задач.

### Как устроен

Модуль включает в себя следующие основные компоненты:

1. **Параметры:**
   - `NUM_CORES` - количество ядер.
   - `DATA_WIDTH`, `ADDRESS_BITS`, `ADDRESS_WIDTH` - ширина данных и адресов.
   - `MEM_ADDRESS_BITS` - количество бит адреса памяти.
   - `SCAN_CYCLES_MIN`, `SCAN_CYCLES_MAX` - параметры для сканирования, определяющие диапазон циклов для отображения данных.

2. **Входные сигналы:**
   - `clock`, `reset` - тактовый сигнал и сигнал сброса.
   - `start` - сигнал запуска.
   - `program_address` - начальные адреса программ для каждого ядра.
   - `scan` - сигнал сканирования для отображения состояния регистров.

3. **Выходные сигналы:**
   - `PC` - текущие значения программных счетчиков для каждого ядра.

4. **Внутренние сигналы:**
   - Различные сигналы для интерфейсов стадий выборки (fetch) и памяти (memory), интерфейсов кэшей и памяти.

### Логика работы

1. **Генерация ядер:**
   Используется цикл `generate` для создания `NUM_CORES` ядер процессора. Для каждого ядра создается экземпляр модуля `five_stage_core`, который представляет собой пятистадийный конвейерный процессор, и модуля `memory_interface`, который обеспечивает взаимодействие ядра с памятью и кэшем.

2. **Интерфейсы стадий выборки и памяти:**
   Определены сигналы для взаимодействия между стадиями выборки инструкций и памяти, такими как `fetch_read`, `fetch_address_out`, `fetch_data_in`, `memory_read`, `memory_write`, `memory_address_out`, `memory_data_out`, и другие.

3. **Кэш и иерархия памяти:**
   Создается экземпляр модуля `cache_hierarchy`, который представляет иерархию кэшей уровня L1 и L2. Модуль управляет взаимодействием между ядрами и кэшами, а также между кэшами и основной памятью.

4. **Интерфейс основной памяти:**
   Модуль `main_memory_interface` управляет взаимодействием между кэшами и основной памятью. Он принимает запросы от кэшей и передает их в основную память, а также обрабатывает ответы от памяти.

5. **Основная память:**
   Модуль `main_memory` реализует основную память, которая хранит данные и инструкции. Он обрабатывает запросы на чтение и запись данных от интерфейса памяти.

### Пример использования

Процессор может быть инициализирован и использован для выполнения программ, загруженных в основную память. Например:

```verilog
module test_processor;
  reg clock;
  reg reset;
  reg start;
  reg [NUM_CORES*ADDRESS_BITS-1:0] program_address;
  wire [NUM_CORES*ADDRESS_BITS-1:0] PC;

  Processor_v4 #(
    .NUM_CORES(2),
    .DATA_WIDTH(32),
    .ADDRESS_BITS(32)
  ) uut (
    .clock(clock),
    .reset(reset),
    .start(start),
    .program_address(program_address),
    .PC(PC),
    .scan(1'b0)
  );

  initial begin
    // Инициализация сигналов
    clock = 0;
    reset = 1;
    start = 0;
    program_address = {32'h00000000, 32'h00000000};

    // Сброс процессора
    #10 reset = 0;
    #10 start = 1;

    // Генерация тактовых импульсов
    forever #5 clock = ~clock;
  end
endmodule
```

В этом примере тестовый модуль инициализирует процессор с двумя ядрами и запускает его. Адреса программ загружаются в память, и процессор начинает выполнение инструкций с этих адресов.

### Заключение

Модуль `Processor_v4` представляет собой многопроцессорную систему с иерархией кэшей и интерфейсом к основной памяти. Он обеспечивает параллельное выполнение задач и эффективное управление данными, что важно для повышения производительности и гибкости системы.


# ------------------------------------------------------------------------------

Модуль `regFile` представляет собой параметризуемый регистровый файл, который используется в процессорах для хранения и доступа к данным. Регистровый файл позволяет читать и записывать данные в регистры по заданным адресам.

### Зачем он нужен

Регистровый файл используется в процессорах для временного хранения данных, к которым требуется быстрый доступ. Он служит для хранения операндов, результатов вычислений и адресов, что важно для эффективного выполнения инструкций и общего управления данными в процессоре.

### Как устроен

Модуль `regFile` включает в себя следующие основные компоненты и функции:

1. **Параметры:**
   - `REG_DATA_WIDTH` - ширина данных регистра.
   - `REG_SEL_BITS` - количество бит для выбора регистра.

2. **Входные сигналы:**
   - `clock` - тактовый сигнал.
   - `reset` - сигнал сброса.
   - `wEn` - сигнал разрешения записи.
   - `write_data` - данные для записи в регистр.
   - `read_sel1`, `read_sel2` - адреса регистров для чтения.
   - `write_sel` - адрес регистра для записи.

3. **Выходные сигналы:**
   - `read_data1`, `read_data2` - данные, прочитанные из регистров.

4. **Внутренние регистры:**
   - `register_file` - массив для хранения значений регистров.

### Логика работы

1. **Синхронная запись в регистры:**
   - При активном сигнале `reset`, регистр с адресом 0 устанавливается в 0.
   - При активном сигнале `wEn` и ненулевом значении `write_sel`, данные `write_data` записываются в регистр с адресом `write_sel`.

2. **Асинхронное чтение данных:**
   - Данные из регистров `read_sel1` и `read_sel2` асинхронно выводятся на `read_data1` и `read_data2`.

### Пример использования

Пример использования регистрационного файла в процессоре, где значения читаются из двух регистров, обрабатываются и записываются в другой регистр:

```verilog
module test_regFile;
  reg clock;
  reg reset;
  reg wEn;
  reg [31:0] write_data;
  reg [4:0] read_sel1;
  reg [4:0] read_sel2;
  reg [4:0] write_sel;
  wire [31:0] read_data1;
  wire [31:0] read_data2;

  regFile #(
    .REG_DATA_WIDTH(32),
    .REG_SEL_BITS(5)
  ) uut (
    .clock(clock),
    .reset(reset),
    .wEn(wEn),
    .write_data(write_data),
    .read_sel1(read_sel1),
    .read_sel2(read_sel2),
    .write_sel(write_sel),
    .read_data1(read_data1),
    .read_data2(read_data2)
  );

  initial begin
    // Инициализация сигналов
    clock = 0;
    reset = 1;
    wEn = 0;
    write_data = 32'h00000000;
    read_sel1 = 5'b00000;
    read_sel2 = 5'b00001;
    write_sel = 5'b00010;

    // Сброс регистра
    #5 reset = 0;

    // Запись данных в регистр
    #5 wEn = 1; write_data = 32'h12345678; write_sel = 5'b00010;
    #5 wEn = 0;

    // Чтение данных из регистров
    #5 read_sel1 = 5'b00010; read_sel2 = 5'b00001;
    #5 $display("Read Data 1: %h, Read Data 2: %h", read_data1, read_data2);

    // Завершение симуляции
    #10 $finish;
  end

  // Генерация тактового сигнала
  always #2.5 clock = ~clock;
endmodule
```

В этом примере создается тестовый модуль, который инициализирует регистровый файл, записывает данные в один из регистров и затем считывает данные из двух регистров, выводя результаты на экран.

### Заключение

Модуль `regFile` представляет собой важный компонент процессора для временного хранения данных и быстрого доступа к ним. Он позволяет эффективно управлять данными в процессоре, обеспечивая параллельное чтение и синхронную запись, что необходимо для высокой производительности и гибкости обработки данных.


# ------------------------------------------------------------------------------

Модуль `replacement_controller` предназначен для управления выбором кэша, который будет заменен в многоуровневом кэшировании. Этот модуль реализует различные политики замены, такие как Least Recently Used (LRU) и случайная замена (Random), а также определяет, если есть доступные пустые пути для записи.

### Зачем он нужен

В многоуровневом кэшировании необходимо определять, какой кэш или путь в кэше следует заменить при записи новых данных. Правильный выбор политики замены может существенно повлиять на производительность системы, обеспечивая оптимальное использование кэш-памяти.

### Как устроен

Модуль `replacement_controller` включает в себя следующие основные компоненты и функции:

1. **Параметры:**
   - `NUMBER_OF_WAYS` - количество путей (ways) в кэше.
   - `INDEX_BITS` - количество бит для индекса кэша.

2. **Входные сигналы:**
   - `clock`, `reset` - тактовый сигнал и сигнал сброса.
   - `ways_in_use` - векторы, указывающие, какие пути в кэше заняты.
   - `current_index` - текущий индекс кэша.
   - `replacement_policy_select` - выбор политики замены (0 - LRU, 1 - Random).
   - `current_access` - текущий доступ к пути.
   - `access_valid` - сигнал, указывающий на валидность текущего доступа.
   - `report` - сигнал для отображения состояния модуля (для отладки).

3. **Выходные сигналы:**
   - `selected_way` - выбранный путь для замены или записи.

4. **Внутренние провода:**
   - `lru_way` - путь, выбранный по политике LRU.
   - `random_way` - случайно выбранный путь.
   - `next_empty_way` - следующий доступный пустой путь.
   - `valid_decode`, `valid_empty_way` - сигналы валидности декодирования и пустого пути.

### Логика работы

1. **Функция log2:**
   Определяет логарифм по основанию 2 от входного значения для вычисления количества битов, необходимых для кодирования.

2. **Инстанцирование LRU и Empty Way Select:**
   - Модуль `LRU` реализует политику замены LRU.
   - Модуль `empty_way_select` определяет следующий доступный пустой путь.

3. **Выбор пути:**
   - Если есть доступный пустой путь (`valid_empty_way`), то он выбирается для записи.
   - В противном случае, выбор осуществляется в зависимости от сигнала `replacement_policy_select`:
     - Если выбрана случайная замена, то используется `random_way`.
     - Если выбрана политика LRU, то используется `lru_way`.

### Пример использования

Пример использования модуля `replacement_controller` в кэш-памяти:

```verilog
module test_replacement_controller;
  reg clock;
  reg reset;
  reg [7:0] ways_in_use;
  reg [7:0] current_index;
  reg replacement_policy_select;
  reg [2:0] current_access;
  reg access_valid;
  wire [7:0] selected_way;

  replacement_controller #(
    .NUMBER_OF_WAYS(8),
    .INDEX_BITS(8)
  ) uut (
    .clock(clock),
    .reset(reset),
    .ways_in_use(ways_in_use),
    .current_index(current_index),
    .replacement_policy_select(replacement_policy_select),
    .current_access(current_access),
    .access_valid(access_valid),
    .selected_way(selected_way)
  );

  initial begin
    // Инициализация сигналов
    clock = 0;
    reset = 1;
    ways_in_use = 8'b00001111; // Первые четыре пути заняты
    current_index = 8'h00;
    replacement_policy_select = 0; // Выбор LRU
    current_access = 3'b010;
    access_valid = 1;

    // Сброс модуля
    #5 reset = 0;
    
    // Обновление сигналов и генерация тактового сигнала
    forever #5 clock = ~clock;
  end

  initial begin
    #10;
    $display("Selected Way: %b", selected_way);

    // Изменение политики замены на случайную
    #10 replacement_policy_select = 1;
    #10;
    $display("Selected Way: %b", selected_way);

    // Завершение симуляции
    #20 $finish;
  end
endmodule
```

В этом примере создается тестовый модуль, который инициализирует `replacement_controller`, задает различные состояния кэша и проверяет, какой путь будет выбран для замены в зависимости от выбранной политики замены (LRU или случайная).

### Заключение

Модуль `replacement_controller` является важным компонентом системы кэширования, обеспечивая гибкий и эффективный выбор пути для замены в зависимости от заданной политики. Он помогает улучшить производительность системы, минимизируя количество промахов кэша и оптимизируя использование кэш-памяти.


# ------------------------------------------------------------------------------

Модуль `snooper` предназначен для реализации наблюдателя (snooper) в системе кэш-памяти. Этот модуль выполняет мониторинг и управление когерентностью кэшей, обрабатывая запросы и сообщения, поступающие от шины и других кэшей. Он обеспечивает корректное управление данными и когерентность в многопроцессорной системе с разделяемой памятью.

### Зачем он нужен

В многопроцессорных системах с разделяемой памятью требуется механизм для обеспечения когерентности кэшей. Наблюдатель (snooper) отслеживает доступы к данным и обновления, чтобы гарантировать, что все процессоры видят консистентное состояние данных. Этот модуль позволяет обработать запросы на чтение, запись и инвалидацию кэш-линий, обеспечивая корректное взаимодействие между кэшами и основной памятью.

### Как устроен

Модуль `snooper` включает в себя следующие основные компоненты и функции:

1. **Параметры:**
   - `CACHE_OFFSET_BITS`, `BUS_OFFSET_BITS` - количество бит для смещения в кэше и на шине.
   - `DATA_WIDTH`, `ADDRESS_WIDTH` - ширина данных и адресов.
   - `MSG_BITS` - количество бит для сообщений.
   - `INDEX_BITS` - количество бит для индекса в кэше.
   - `COHERENCE_BITS`, `STATUS_BITS` - количество бит для когерентности и статуса.
   - `NUMBER_OF_WAYS` - количество путей в кэше.
   - `MAX_OFFSET_BITS` - максимальное количество бит для смещения.

2. **Входные сигналы:**
   - `clock`, `reset` - тактовый сигнал и сигнал сброса.
   - `data_in` - входные данные из кэша.
   - `matched_way` - индекс совпавшего пути.
   - `coh_bits`, `status_bits` - биты когерентности и статуса.
   - `hit` - сигнал попадания в кэш.
   - `read`, `write`, `invalidate` - сигналы управления чтением, записью и инвалидацией.
   - `index`, `tag`, `meta_data` - индекс, тэг и метаданные для кэш-линии.
   - `data_out`, `way_select` - выходные данные и выбранный путь.
   - `intf_msg`, `intf_address`, `intf_data` - сообщения, адреса и данные от интерфейса L1 шины.
   - `bus_msg`, `bus_address`, `req_ready`, `bus_master`, `curr_offset` - сообщения, адреса и сигналы управления от общей шины.

3. **Выходные сигналы:**
   - `snoop_msg`, `snoop_address`, `snoop_data` - сообщения, адреса и данные для наблюдателя (snooper).

4. **Внутренние сигналы и переменные:**
   - `state` - текущее состояние конечного автомата (FSM).
   - `r_*` - регистры для хранения промежуточных данных и сигналов.
   - `w_cache_data` - разделенные данные кэша.
   - `offset_diff`, `ratio`, `wider_transfer`, `wider_line` - сигналы для вычисления смещений и ширины передачи данных.
   - `read_req`, `write_req`, `flush_req`, `mflush_req` - сигналы для запросов на чтение, запись и очистку.
   - `dirty` - сигнал для обозначения грязного (модифицированного) состояния кэш-линии.

### Логика работы

1. **Функция log2:**
   Определяет логарифм по основанию 2 от входного значения для вычисления количества битов, необходимых для кодирования.

2. **FSM (конечный автомат):**
   - Состояние `IDLE`: ожидает запросы на чтение, запись или инвалидацию.
   - Состояние `START`: инициализирует операции чтения и инвалидации.
   - Состояние `READ_LINE`: выполняет чтение линии из кэша.
   - Состояние `ACTION`: выполняет действия в зависимости от типа запроса (например, запись, инвалидация).
   - Состояние `WAIT_FOR_RESP`: ожидает ответа на запрос от интерфейса или шины.
   - Состояние `INVALIDATE_LINE`: выполняет инвалидацию кэш-линий.
   - Состояние `WRITE_LINE`: выполняет запись кэш-линий.

3. **Обработка запросов:**
   - Обрабатывает запросы на чтение (R_REQ), запись (WS_BCAST), инвалидацию (FLUSH_S, REQ_FLUSH) и запросы на владение (RFO_BCAST).
   - При попадании в кэш (hit) проверяет состояние кэш-линии (чистая или грязная) и выполняет соответствующие действия (инвалидация, запись, чтение).
   - При промахе в кэше (miss) выполняет действия в зависимости от текущего состояния и запроса.

### Пример использования

Пример использования модуля `snooper` в системе кэш-памяти:

```verilog
module test_snooper;
  reg clock;
  reg reset;
  reg [31:0] data_in;
  reg [1:0] matched_way;
  reg [1:0] coh_bits;
  reg [1:0] status_bits;
  reg hit;
  wire read, write, invalidate;
  wire [7:0] index;
  wire [19:0] tag;
  wire [3:0] meta_data;
  wire [31:0] data_out;
  wire [1:0] way_select;

  reg [3:0] intf_msg;
  reg [31:0] intf_address;
  reg [31:0] intf_data;
  wire [3:0] snoop_msg;
  wire [31:0] snoop_address;
  wire [31:0] snoop_data;

  reg [3:0] bus_msg;
  reg [31:0] bus_address;
  reg req_ready;
  reg bus_master;
  reg [1:0] curr_offset;

  snooper #(
    .CACHE_OFFSET_BITS(2),
    .BUS_OFFSET_BITS(1),
    .DATA_WIDTH(32),
    .ADDRESS_WIDTH(32),
    .MSG_BITS(4),
    .INDEX_BITS(8),
    .COHERENCE_BITS(2),
    .STATUS_BITS(2),
    .NUMBER_OF_WAYS(4),
    .MAX_OFFSET_BITS(2)
  ) uut (
    .clock(clock),
    .reset(reset),
    .data_in(data_in),
    .matched_way(matched_way),
    .coh_bits(coh_bits),
    .status_bits(status_bits),
    .hit(hit),
    .read(read),
    .write(write),
    .invalidate(invalidate),
    .index(index),
    .tag(tag),
    .meta_data(meta_data),
    .data_out(data_out),
    .way_select(way_select),
    .intf_msg(intf_msg),
    .intf_address(intf_address),
    .intf_data(intf_data),
    .snoop_msg(snoop_msg),
    .snoop_address(snoop_address),
    .snoop_data(snoop_data),
    .bus_msg(bus_msg),
    .bus_address(bus_address),
    .req_ready(req_ready),
    .bus_master(bus_master),
    .curr_offset(curr_offset)
  );

  initial begin
    // Инициализация сигналов
    clock = 0;
    reset = 1;
    data_in = 32'h0;
    matched_way = 2'b00;
    coh_bits = 2'b00;
    status_bits = 2'b00;
    hit = 0;
    intf_msg = 4'b0000;
    intf_address = 32'h0;
    intf_data = 32'h0;
    bus_msg = 4'b0000;
    bus_address = 32'h0;
    req_ready = 0;
    bus_master = 0;
    curr_offset = 2'b00;

    // Сброс модуля
    #10 reset = 0;
    
    // Обновление сигналов и генерация тактового сигнала
    forever #5 clock = ~clock;
  end

  initial begin
    // Пример запроса на чтение
    #20 bus_msg = 4'b0001; // R_REQ
    bus_address = 32'h00000010;
    req_ready = 1;
    hit = 1;

    #20;
    $display("Snoop Message: %b", snoop_msg);
    $display("Snoop Address: %h", snoop_address);

    // Завершение симуляции
    #100 $finish;
  end
endmodule
```

В этом примере создается тестовый модуль, который инициализирует `snooper`, задает различные состояния и проверяет, как модуль обрабатывает запросы на чтение и запись, обеспечивая когерентность кэша.

### Заключение

Модуль `snooper` является важным компонентом системы кэширования, обеспечивая когерентность данных в многопроцессорной среде. Он

 обрабатывает запросы на чтение, запись и инвалидацию кэш-линий, гарантируя, что все процессоры видят консистентное состояние данных.


# ------------------------------------------------------------------------------

 Тестовый модуль `tb_Processor_v4` предназначен для симуляции и проверки работы процессора `Processor_v4` с двумя ядрами. Он загружает программу в память, инициализирует регистры, запускает процессор и следит за выполнением программ, определяя, когда каждое ядро завершает выполнение.

### Основные компоненты и функции

1. **Параметры:**
   - `NUM_CORES`, `DATA_WIDTH`, `ADDRESS_BITS`, `MEM_ADDRESS_BITS`, `SCAN_CYCLES_MIN`, `SCAN_CYCLES_MAX`: параметры конфигурации процессора.
   - `PROGRAM`, `LOG_FILE`: имена файла программы и лог-файла.

2. **Сигналы:**
   - `clock`, `reset`, `start`, `program_address`: основные сигналы управления процессором.
   - `PC`: текущее значение счетчика команд для каждого ядра.
   - `PC1`, `PC2`: значения счетчика команд для каждого конкретного ядра.
   - `scan`: сигнал для сканирования.

3. **Переменные:**
   - `core_finish_count`, `core0_finished`, `core1_finished`: переменные для отслеживания завершения работы ядер.
   - `start_time`, `end_time`, `total_cycles`: переменные для измерения времени выполнения.

### Процесс работы

1. **Генерация тактового сигнала:**
   ```verilog
   always #1 clock = ~clock;
   ```

2. **Инициализация памяти и регистров:**
   ```verilog
   initial begin
       for (x = 0; x < 2 ** MEM_ADDRESS_BITS; x = x+1) begin
           dut.memory.BRAM_inst.ram[x] = 32'd0;
       end
       for (x = 0; x < 32; x = x+1) begin
           `REGISTER_FILE0[x] = 32'd0; 
           `REGISTER_FILE1[x] = 32'd0;
       end
       $readmemh(PROGRAM, dut.memory.BRAM_inst.ram);
   end
   ```

3. **Инициализация сигналов и запуск процессора:**
   ```verilog
   initial begin
       clock = 1;
       reset = 1;
       scan = 0;
       start = 0;
       core_finish_count = 0;
       for (core_i = 0; core_i < NUM_CORES; core_i = core_i+1) begin
           program_address[core_i*ADDRESS_BITS +: ADDRESS_BITS] = core_i*32'h0000_0010;
       end

       #10 #1 reset = 0;
       start = 1;
       start_time = $time;
       #1 start = 0;

       log_file = $fopen(LOG_FILE, "a+");
       if (!log_file) begin
           $display("Could not open log file... Exiting!");
           $finish();
       end
   end
   ```

4. **Мониторинг выполнения программ:**
   ```verilog
   always begin
       #1
       if ((`CURRENT_PC0 == 32'h00000b0 || `CURRENT_PC0 == 32'h00000b0) && core0_finished !== 1) begin
           end_time = $time;
           total_cycles = (end_time-start_time)/2;
           #100 
           core_finish_count = core_finish_count+1;
           core0_finished = 1;
           $display("\nCore 0 gcd is finished!\n");
           $display("\nRun Time (cycles): %d", total_cycles);
           $fdisplay(log_file, "\nRun Time (cycles): %d", total_cycles);
           if (`REGISTER_FILE0[9] == 32'h0000010) begin
               $display("gcd:\nTest Passed!\n\n");
               $fdisplay(log_file, "gcd:\nTest Passed!\n\n");
           end else begin
               $display("gcd:\nTest Failed!\n\n");
               $fdisplay(log_file, "gcd:\nTest Failed!\n\n");
               for (x = 0; x < 32; x = x+1) begin
                   $display("%d: %h", x, `REGISTER_FILE0[x]);
                   $fdisplay(log_file, "%d: %h", x, `REGISTER_FILE0[x]);
               end
               $display("");
               $fdisplay(log_file, "");
           end

           if (core_finish_count == NUM_CORES) begin
               $display("Finished running tests for %d cores\n", core_finish_count);
               $fclose(log_file);
               $stop();
           end
       end

       if ((`CURRENT_PC1 == 32'h0000168 || `CURRENT_PC1 == 32'h0000168) && core1_finished !== 1) begin
           end_time = $time;
           total_cycles = (end_time-start_time)/2;
           #100 
           core_finish_count = core_finish_count+1;
           core1_finished = 1;
           $display("\nCore 1 hanoi is finished!\n");
           $display("\nRun Time (cycles): %d", total_cycles);
           $fdisplay(log_file, "\nRun Time (cycles): %d", total_cycles);
           if (`REGISTER_FILE1[9] == 32'h000000f) begin
               $display("hanoi:\nTest Passed!\n\n");
               $fdisplay(log_file, "hanoi:\nTest Passed!\n\n");
           end else begin
               $display("hanoi:\nTest Failed!\n\n");
               $fdisplay(log_file, "hanoi:\nTest Failed!\n\n");
               for (x = 0; x < 32; x = x+1) begin
                   $display("%d: %h", x, `REGISTER_FILE1[x]);
                   $fdisplay(log_file, "%d: %h", x, `REGISTER_FILE1[x]);
               end
               $display("");
               $fdisplay(log_file, "");
           end

           if (core_finish_count == NUM_CORES) begin
               $display("Finished running tests for %d cores\n", core_finish_count);
               $fclose(log_file);
               $stop();
           end
       end
   end
   ```

### Заключение

Этот тестовый модуль позволяет симулировать работу процессора `Processor_v4` с двумя ядрами, загружая в память программу, инициализируя регистры и отслеживая выполнение программы каждым ядром. Модуль обеспечивает проверку правильности работы процессора и позволяет измерять время выполнения программ.


# ------------------------------------------------------------------------------

Модуль `writeback_unit` отвечает за финальную стадию конвейерного процессора, где результаты вычислений или данных из памяти записываются обратно в регистровый файл. Этот модуль важен для завершения выполнения инструкций и обновления состояния процессора.

### Зачем он нужен

Модуль записи результатов (writeback unit) необходим для завершения выполнения инструкций в процессоре. Он берет результаты вычислений или данные, загруженные из памяти, и записывает их в соответствующий регистр в регистровом файле. Это позволяет последующим инструкциям использовать эти данные.

### Как устроен

Модуль включает следующие компоненты и сигналы:

1. **Параметры:**
   - `CORE` - номер ядра.
   - `DATA_WIDTH` - ширина данных.
   - `SCAN_CYCLES_MIN` и `SCAN_CYCLES_MAX` - параметры для сканирования.

2. **Входные сигналы:**
   - `clock` - тактовый сигнал.
   - `reset` - сигнал сброса.
   - `opWrite` - сигнал разрешения записи.
   - `opSel` - селектор источника данных (результат ALU или данные из памяти).
   - `opReg` - номер регистра для записи.
   - `ALU_result` - результат вычислений ALU.
   - `memory_data` - данные из памяти.
   - `scan` - сигнал сканирования.

3. **Выходные сигналы:**
   - `write` - сигнал записи в регистровый файл.
   - `write_reg` - номер регистра для записи.
   - `write_data` - данные для записи.

### Логика работы

1. **Определение данных для записи:**
   - Если сигнал `opSel` активен, выбираются данные из памяти (`memory_data`).
   - Если сигнал `opSel` неактивен, выбирается результат ALU (`ALU_result`).

2. **Присваивание данных для записи:**
   - Выбранные данные присваиваются `write_data`.
   - Номер регистра для записи присваивается `write_reg`.
   - Сигнал разрешения записи присваивается `write`.

3. **Отображение состояния:**
   - Если активен сигнал `scan`, на каждом тактовом цикле отображаются текущие значения сигналов для отладки.

### Пример использования

Пример использования модуля `writeback_unit` в конвейерном процессоре:

```verilog
module test_writeback_unit;
  reg clock;
  reg reset;
  reg opWrite;
  reg opSel;
  reg [4:0] opReg;
  reg [31:0] ALU_result;
  reg [31:0] memory_data;
  wire write;
  wire [4:0] write_reg;
  wire [31:0] write_data;
  reg scan;

  writeback_unit #(
    .CORE(0),
    .DATA_WIDTH(32)
  ) uut (
    .clock(clock),
    .reset(reset),
    .opWrite(opWrite),
    .opSel(opSel),
    .opReg(opReg),
    .ALU_result(ALU_result),
    .memory_data(memory_data),
    .write(write),
    .write_reg(write_reg),
    .write_data(write_data),
    .scan(scan)
  );

  initial begin
    clock = 0;
    reset = 1;
    opWrite = 0;
    opSel = 0;
    opReg = 0;
    ALU_result = 0;
    memory_data = 0;
    scan = 0;

    #5 reset = 0;
    #5 opWrite = 1; opSel = 0; opReg = 5; ALU_result = 32'hA5A5A5A5;
    #10 opSel = 1; memory_data = 32'h5A5A5A5A;
    #10 opWrite = 0;

    #50 $finish;
  end

  always #1 clock = ~clock;

endmodule
```

### Заключение

Модуль `writeback_unit` играет ключевую роль в завершении выполнения инструкций в процессоре. Он берет результаты вычислений и данные из памяти, выбирает соответствующие данные и записывает их обратно в регистровый файл. Это обеспечивает обновление состояния процессора и доступность данных для последующих инструкций.
